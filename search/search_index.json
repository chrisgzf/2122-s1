{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"CS1010 Semester 1, AY 2020/21 Welcome to CS1010! Here are some things that you can do while waiting for the semester to start. Getting Ready for CS1010 Take a Look at General CS1010 Information Take a look at the crucial information about CS1010 here. Scan through the learning outcomes to know what you are expected to learn in this module. Note down the important dates on your calendar. Read about CS1010 Policies The general policies for CS1010 is posted. Go through it to see what is expected. Read Feedback on CS1010 from Two Years Ago This semester's CS1010 will be conducted in a similar style with the version in 2018. Read the comments from that batch of students to know what to expect. Explore Some Additional Readings Some extra reading materials curated by Wei Tsang are available . In particular, check out the articles under Must Read section. If you have some programming background and are wondering why we are teaching C, read the articles under Why C section. Enable Your Piazza Account You should have received an email inviting you to create a Piazza account and enroll in the module Q&A forum. Please join CS1010 on Piazza. Enable Your SoC Account Go to https://mysoc.nus.edu.sg/~newacct and create your SoC Unix Account if you have not done so. Activate \"General Unix Servers\" and \"The SoC Compute Cluster\" in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi Create a GitHub Account Create a GitHub account if you do not have one. This account should stay with you for your professional career. So choose the username wisely. Get a Head-Start with Unix and Vim If you did not register for the SoC Unix@Home Workshop , you can still head to the website and take a look at the notes and follow through with the examples. If you have questions or face any issues, ask on Piazza","title":"Home"},{"location":"index.html#cs1010","text":"","title":"CS1010"},{"location":"index.html#semester-1-ay-202021","text":"Welcome to CS1010! Here are some things that you can do while waiting for the semester to start.","title":"Semester 1, AY 2020/21"},{"location":"index.html#getting-ready-for-cs1010","text":"","title":"Getting Ready for CS1010"},{"location":"index.html#take-a-look-at-general-cs1010-information","text":"Take a look at the crucial information about CS1010 here. Scan through the learning outcomes to know what you are expected to learn in this module. Note down the important dates on your calendar.","title":"Take a Look at General CS1010 Information"},{"location":"index.html#read-about-cs1010-policies","text":"The general policies for CS1010 is posted. Go through it to see what is expected.","title":"Read about CS1010 Policies"},{"location":"index.html#read-feedback-on-cs1010-from-two-years-ago","text":"This semester's CS1010 will be conducted in a similar style with the version in 2018. Read the comments from that batch of students to know what to expect.","title":"Read Feedback on CS1010 from Two Years Ago"},{"location":"index.html#explore-some-additional-readings","text":"Some extra reading materials curated by Wei Tsang are available . In particular, check out the articles under Must Read section. If you have some programming background and are wondering why we are teaching C, read the articles under Why C section.","title":"Explore Some Additional Readings"},{"location":"index.html#enable-your-piazza-account","text":"You should have received an email inviting you to create a Piazza account and enroll in the module Q&A forum. Please join CS1010 on Piazza.","title":"Enable Your Piazza Account"},{"location":"index.html#enable-your-soc-account","text":"Go to https://mysoc.nus.edu.sg/~newacct and create your SoC Unix Account if you have not done so. Activate \"General Unix Servers\" and \"The SoC Compute Cluster\" in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi","title":"Enable Your SoC Account"},{"location":"index.html#create-a-github-account","text":"Create a GitHub account if you do not have one. This account should stay with you for your professional career. So choose the username wisely.","title":"Create a GitHub Account"},{"location":"index.html#get-a-head-start-with-unix-and-vim","text":"If you did not register for the SoC Unix@Home Workshop , you can still head to the website and take a look at the notes and follow through with the examples. If you have questions or face any issues, ask on Piazza","title":"Get a Head-Start with Unix and Vim"},{"location":"about.html","text":"About CS1010 Module Description This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students. Who/Where/When Instructor : Ooi Wei Tsang and Daren Ler Lecture Venue : Online Lecture Time : Every Monday, 12noon - 2pm Q&A Hour via Zoom : Every Tuesday, 4pm - 5pm (Wei Tsang) Every Friday, 4pm - 5pm (Daren) Student Tutors : Aaron Ong Adi Nata Bennett Clement Chan Jun Hui Christopher Goh Zhen Fung Dao Ngoc Hieu David Livingstone Felix Halim Francisco Chensan Georgie Lee Hubertus Adhy Pratama Setiawan Justin Tzuriel Krisnahadi Jusuf Nathanael Khenus Tan Jia Liang Leah Roselyn James Liau Kai Jie Liu Zhuohao Muhammad Ahmed bin Anwar Bahajjaj Neil Banerjee Nicholas Teh Pang Jun Xian, Dylan Stefina Aryani Winoto Sun Yu Cheng Vasavada Tejas Wamika Malik Wang Zesong Xia Fuxi Important Dates Midterm Assessment : Monday, 28 September, 2020 (12noon - 2pm) Final Assessment : Tuesday, 24 Nov, 2020 (5pm - 7pm) Practical Exam 1 : Saturday, 3 October, 2020 (9am - 12noon) Practical Exam 2 : Saturday, 7 November, 2020 (9am - 12noon) Assessment Weightage Programming Assignments : 30% Final Assessment : 25% Midterm Assessment : 10% Practical Exam 1 : 10% Practical Exam 2 : 15% Online Quizzes : 10%","title":"About CS1010"},{"location":"about.html#about-cs1010","text":"","title":"About CS1010"},{"location":"about.html#module-description","text":"This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.","title":"Module Description"},{"location":"about.html#whowherewhen","text":"Instructor : Ooi Wei Tsang and Daren Ler Lecture Venue : Online Lecture Time : Every Monday, 12noon - 2pm Q&A Hour via Zoom : Every Tuesday, 4pm - 5pm (Wei Tsang) Every Friday, 4pm - 5pm (Daren) Student Tutors : Aaron Ong Adi Nata Bennett Clement Chan Jun Hui Christopher Goh Zhen Fung Dao Ngoc Hieu David Livingstone Felix Halim Francisco Chensan Georgie Lee Hubertus Adhy Pratama Setiawan Justin Tzuriel Krisnahadi Jusuf Nathanael Khenus Tan Jia Liang Leah Roselyn James Liau Kai Jie Liu Zhuohao Muhammad Ahmed bin Anwar Bahajjaj Neil Banerjee Nicholas Teh Pang Jun Xian, Dylan Stefina Aryani Winoto Sun Yu Cheng Vasavada Tejas Wamika Malik Wang Zesong Xia Fuxi","title":"Who/Where/When"},{"location":"about.html#important-dates","text":"Midterm Assessment : Monday, 28 September, 2020 (12noon - 2pm) Final Assessment : Tuesday, 24 Nov, 2020 (5pm - 7pm) Practical Exam 1 : Saturday, 3 October, 2020 (9am - 12noon) Practical Exam 2 : Saturday, 7 November, 2020 (9am - 12noon)","title":"Important Dates"},{"location":"about.html#assessment-weightage","text":"Programming Assignments : 30% Final Assessment : 25% Midterm Assessment : 10% Practical Exam 1 : 10% Practical Exam 2 : 15% Online Quizzes : 10%","title":"Assessment Weightage"},{"location":"accounts.html","text":"CS1010 Accounts We will be using a variety of services for CS1010. To take CS1010, please make sure you have the following accounts: SoC UNIX Account You can get one here: https://mysoc.nus.edu.sg/~newacct/ This account allows you to access SoC UNIX resources, including the main computing host running Solaris, sunfire , and computer clusters running Ubuntu / CentOS. We will be using the compute clusters for CS1010. Make sure that \"General Unix Servers\" and \"The SoC Compute Cluster\" are enabled in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi GitHub Account CS1010 uses GitHub Classroom for programming assignment submissions and grading. You should register for a GitHub account if you do not have one. This account will likely stay with you for the rest of your computing career. So choose your username wisely. Piazza Account CS1010 uses Piazza for Q&A and discussion. You should have received an email to register for Piazza.","title":"Accounts"},{"location":"accounts.html#cs1010-accounts","text":"We will be using a variety of services for CS1010. To take CS1010, please make sure you have the following accounts:","title":"CS1010 Accounts"},{"location":"accounts.html#soc-unix-account","text":"You can get one here: https://mysoc.nus.edu.sg/~newacct/ This account allows you to access SoC UNIX resources, including the main computing host running Solaris, sunfire , and computer clusters running Ubuntu / CentOS. We will be using the compute clusters for CS1010. Make sure that \"General Unix Servers\" and \"The SoC Compute Cluster\" are enabled in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi","title":"SoC UNIX Account"},{"location":"accounts.html#github-account","text":"CS1010 uses GitHub Classroom for programming assignment submissions and grading. You should register for a GitHub account if you do not have one. This account will likely stay with you for the rest of your computing career. So choose your username wisely.","title":"GitHub Account"},{"location":"accounts.html#piazza-account","text":"CS1010 uses Piazza for Q&A and discussion. You should have received an email to register for Piazza.","title":"Piazza Account"},{"location":"clang.html","text":"CS1010 Compilation Guide 1. Compile a standalone C program Suppose we have a standalone C program teh.c that does not use any external libraries. We can compile the program using the command ooiwt@pe118:~$ clang teh.c This command should create an executable called a.out in the current directory, which you can then run with: ooiwt@pe118:~$ ./a.out 2. Renaming executable file The name a.out is an abbreviation for assembler output , a name that many compilers kept as the default output name since the 60s. We should, however, give our executable more descriptive name, by using the -o flag. ( o is the mnemonic for output). ooiwt@pe118:~$ clang teh.c -o teh or ooiwt@pe118:~$ clang -o teh teh.c The command above would create an executable called teh . Beware of the order If you are not careful and run the following command instead: ooiwt@pe118:~$ clang -o teh.c teh clang would overwrite your code teh.c -- all your hard work will be gone!! 3. Warning for possible bugs. The clang checks for syntax errors in your C files -- i.e., things that violate the C syntax rules. The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules. You can ask clang to warn you about this, using the -W flag ( W is the mnemonic for warning -- note the capital W). The manual for clang lists different types of warnings that clang can warn you about. For simplicity, we will ask clang to warn us about everything, by enabling all warnings. The command to do so is: ooiwt@pe118:~$ clang -Wall teh.c -o teh For beginners, it is highly recommended that you always compile with -Wall flag. 4. Generating additional information for debugging. In order to use the debugger lldb to trace through and debug your program, clang needs to generate additional information and store them in the executable file. We can instruct clang to generate them with the flag -g ( g for generate). ooiwt@pe118:~$ clang -Wall -g teh.c -o teh It is recommended that you always compile with -g flags during the development phase. If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the -g flag and compile with the optimization flags (e.g., -O ) instead. 5. Linking with the standard library. To link with a standard library, we use the -l flag to specify the name of the library to link. For instance, to link with the C standard math library (abbreviated as m ), you issue the command: ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm 6. Linking with 3rd party library By default, clang looks for headers and libraries in the systems directories ( /usr/include , /usr/lib , etc) and the current working directory. If you use a third-party library, you usually need to tell clang where to look for the corresponding headers and libraries. You can use the -I flag and the -L flag for these purposes. For instance, if you have a library installed under your home called citadel , and the file citadel.h can be found under ~/citadel/include and the file libcitadel.a can be found under ~/citadel/lib , to tell clang where to find these files, you can compile with: ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel","title":"CLang"},{"location":"clang.html#cs1010-compilation-guide","text":"","title":"CS1010 Compilation Guide"},{"location":"clang.html#1-compile-a-standalone-c-program","text":"Suppose we have a standalone C program teh.c that does not use any external libraries. We can compile the program using the command ooiwt@pe118:~$ clang teh.c This command should create an executable called a.out in the current directory, which you can then run with: ooiwt@pe118:~$ ./a.out","title":"1. Compile a standalone C program"},{"location":"clang.html#2-renaming-executable-file","text":"The name a.out is an abbreviation for assembler output , a name that many compilers kept as the default output name since the 60s. We should, however, give our executable more descriptive name, by using the -o flag. ( o is the mnemonic for output). ooiwt@pe118:~$ clang teh.c -o teh or ooiwt@pe118:~$ clang -o teh teh.c The command above would create an executable called teh . Beware of the order If you are not careful and run the following command instead: ooiwt@pe118:~$ clang -o teh.c teh clang would overwrite your code teh.c -- all your hard work will be gone!!","title":"2. Renaming executable file"},{"location":"clang.html#3-warning-for-possible-bugs","text":"The clang checks for syntax errors in your C files -- i.e., things that violate the C syntax rules. The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules. You can ask clang to warn you about this, using the -W flag ( W is the mnemonic for warning -- note the capital W). The manual for clang lists different types of warnings that clang can warn you about. For simplicity, we will ask clang to warn us about everything, by enabling all warnings. The command to do so is: ooiwt@pe118:~$ clang -Wall teh.c -o teh For beginners, it is highly recommended that you always compile with -Wall flag.","title":"3. Warning for possible bugs."},{"location":"clang.html#4-generating-additional-information-for-debugging","text":"In order to use the debugger lldb to trace through and debug your program, clang needs to generate additional information and store them in the executable file. We can instruct clang to generate them with the flag -g ( g for generate). ooiwt@pe118:~$ clang -Wall -g teh.c -o teh It is recommended that you always compile with -g flags during the development phase. If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the -g flag and compile with the optimization flags (e.g., -O ) instead.","title":"4. Generating additional information for debugging."},{"location":"clang.html#5-linking-with-the-standard-library","text":"To link with a standard library, we use the -l flag to specify the name of the library to link. For instance, to link with the C standard math library (abbreviated as m ), you issue the command: ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm","title":"5. Linking with the standard library."},{"location":"clang.html#6-linking-with-3rd-party-library","text":"By default, clang looks for headers and libraries in the systems directories ( /usr/include , /usr/lib , etc) and the current working directory. If you use a third-party library, you usually need to tell clang where to look for the corresponding headers and libraries. You can use the -I flag and the -L flag for these purposes. For instance, if you have a library installed under your home called citadel , and the file citadel.h can be found under ~/citadel/include and the file libcitadel.a can be found under ~/citadel/lib , to tell clang where to find these files, you can compile with: ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel","title":"6. Linking with 3rd party library"},{"location":"environments.html","text":"The CS1010 Programming Environment C is a common programming language and you can find different implementations of C compiler on many platforms. Wikipedia lists more than 40 different C compilers . These different compilers support different processor architecture, operating systems, may behave slightly differently, and may support different features of C standards. It is therefore important for CS1010 to stick to a single platform and single compiler. Our platform of choice is Ubuntu 16.04 (or later) using the clang compiler ( version 3.4.2 or later ). The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ..., pe120 . ( pe stands for \"programming environment\"). You can choose which of the 10 hosts to use. You share the same home directory across all 10 hosts (this home directory, however, is different from that of sunfire ). For simplicity, the following guide uses pe111 in all examples. Do keep in mind that you can use other hosts for CS1010 to spread out the load. While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs. It is therefore advisable for you to familiarize with accessing remote computing servers via ssh and edit your program with either vim or macro . Basic Requirements You need to have an SoC UNIX account. If you do not have one, you can apply for one online . Once you have an account, you need to [activate your access to the PE hosts] ( https://mysoc.nus.edu.sg/~myacct/services.cgi ), which is part of the SoC computer clusters. You need an ssh client. macOS and Linux users should already have it installed by default. Windows 10 users should install the Windows Subsystem for Linux and use Linux. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command lines instructions below do not apply. The Command to SSH Run: ssh <username>@pe111.comp.nus.edu.sg Replace <username> with your SoC UNIX username, for instance, I would do: ssh ooiwt@pe111.comp.nus.edu.sg After the command above, following the instructions on the screen. The first time you ever connect to pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your SoC UNIX password. Accessing The PE Hosts from Outside SoC The PE hosts can only be accessed from within the School of Computing networks. If you want to access it from outside, there are two ways. Using SoC VPN One way is to set up a Virtual Private Network (VPN) (See instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network. Tunneling through Sunfire The alternative is to use ssh tunnels. SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See more details here .) Since sunfire is situated within the School of Computing network, sunfire is able to access the VM. This opens the possibility of connecting from your device (using an Internet connection from a local telco) to sunfire , and then from sunfire to the VM. There are two ways to achieve this, and in both ways, it appears to the PE hosts that Sunfire is the client. SSH Using Sunfire's Terminal Connect to Sunfire at sunfire.comp.nus.edu.sg via your favorite SSH client. After logging in, run the command ssh pe111 to connect to the programming environment. This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire. Refer to instructions below on how to connect via SSH. SSH Port Forwarding SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments. Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server (e.g., pe111 ). This method causes the host to seem as if it is hosted on a local port, e.g. localhost:1010 , allowing you to use your favorite SCP program (e.g. FileZilla ) to access the PE host. To use local port forwarding (from local port 1010 ), connect to sunfire using ssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg This command opens an SSH tunnel from port 1010 of your machine to port 22 (the default SSH port) of pe111.comp.nus.edu.sg via sunfire . After successful login, open a separate SSH (or SCP) connection from your machine to localhost at port 1010 to access the PE host: ssh <username>@localhost -p 1000 PuTTY supports SSH port forwarding, so this setup can also be used on Windows. Setting up SSH Keys Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication. You can use ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on PE pe111 . On pe111 , run cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on PE are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote machine are set to 600 . Once set up, you need not enter your password every time you run ssh or scp .","title":"Programming Environments"},{"location":"environments.html#the-cs1010-programming-environment","text":"C is a common programming language and you can find different implementations of C compiler on many platforms. Wikipedia lists more than 40 different C compilers . These different compilers support different processor architecture, operating systems, may behave slightly differently, and may support different features of C standards. It is therefore important for CS1010 to stick to a single platform and single compiler. Our platform of choice is Ubuntu 16.04 (or later) using the clang compiler ( version 3.4.2 or later ). The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ..., pe120 . ( pe stands for \"programming environment\"). You can choose which of the 10 hosts to use. You share the same home directory across all 10 hosts (this home directory, however, is different from that of sunfire ). For simplicity, the following guide uses pe111 in all examples. Do keep in mind that you can use other hosts for CS1010 to spread out the load. While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using the desktop PCs in the programming labs. It is therefore advisable for you to familiarize with accessing remote computing servers via ssh and edit your program with either vim or macro .","title":"The CS1010 Programming Environment"},{"location":"environments.html#basic-requirements","text":"You need to have an SoC UNIX account. If you do not have one, you can apply for one online . Once you have an account, you need to [activate your access to the PE hosts] ( https://mysoc.nus.edu.sg/~myacct/services.cgi ), which is part of the SoC computer clusters. You need an ssh client. macOS and Linux users should already have it installed by default. Windows 10 users should install the Windows Subsystem for Linux and use Linux. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command lines instructions below do not apply.","title":"Basic Requirements"},{"location":"environments.html#the-command-to-ssh","text":"Run: ssh <username>@pe111.comp.nus.edu.sg Replace <username> with your SoC UNIX username, for instance, I would do: ssh ooiwt@pe111.comp.nus.edu.sg After the command above, following the instructions on the screen. The first time you ever connect to pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your SoC UNIX password.","title":"The Command to SSH"},{"location":"environments.html#accessing-the-pe-hosts-from-outside-soc","text":"The PE hosts can only be accessed from within the School of Computing networks. If you want to access it from outside, there are two ways.","title":"Accessing The PE Hosts from Outside SoC"},{"location":"environments.html#using-soc-vpn","text":"One way is to set up a Virtual Private Network (VPN) (See instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network.","title":"Using SoC VPN"},{"location":"environments.html#tunneling-through-sunfire","text":"The alternative is to use ssh tunnels. SoC's Sunfire ( sunfire.comp.nus.edu.sg ) is configured to allow your connection if it's originating from a local telco. (See more details here .) Since sunfire is situated within the School of Computing network, sunfire is able to access the VM. This opens the possibility of connecting from your device (using an Internet connection from a local telco) to sunfire , and then from sunfire to the VM. There are two ways to achieve this, and in both ways, it appears to the PE hosts that Sunfire is the client.","title":"Tunneling through Sunfire"},{"location":"environments.html#ssh-using-sunfires-terminal","text":"Connect to Sunfire at sunfire.comp.nus.edu.sg via your favorite SSH client. After logging in, run the command ssh pe111 to connect to the programming environment. This effectively starts an SSH session to the programming environment from within your existing SSH session to Sunfire. Refer to instructions below on how to connect via SSH.","title":"SSH Using Sunfire's Terminal"},{"location":"environments.html#ssh-port-forwarding","text":"SSH has built-in support for local and remote port forwarding, and local port forwarding can be used to connect to the programming environments. Local port forwarding means that a port of the SSH client (your machine) is forwarded to the SSH server ( sunfire ), which opens a connection to a preset destination server (e.g., pe111 ). This method causes the host to seem as if it is hosted on a local port, e.g. localhost:1010 , allowing you to use your favorite SCP program (e.g. FileZilla ) to access the PE host. To use local port forwarding (from local port 1010 ), connect to sunfire using ssh -L 1010:pe111.comp.nus.edu.sg:22 <username>@sunfire.comp.nus.edu.sg This command opens an SSH tunnel from port 1010 of your machine to port 22 (the default SSH port) of pe111.comp.nus.edu.sg via sunfire . After successful login, open a separate SSH (or SCP) connection from your machine to localhost at port 1010 to access the PE host: ssh <username>@localhost -p 1000 PuTTY supports SSH port forwarding, so this setup can also be used on Windows.","title":"SSH Port Forwarding"},{"location":"environments.html#setting-up-ssh-keys","text":"Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication. You can use ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on PE pe111 . On pe111 , run cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on PE are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote machine are set to 600 . Once set up, you need not enter your password every time you run ssh or scp .","title":"Setting up SSH Keys"},{"location":"outcomes.html","text":"After taking CS1010, students should be familiar with fundamental programming concepts and methodology (variables, assignments, conditions, branches, loops, functions, recursions, structures); be familiar with and appreciate good programming practice, and apply it to follow-up courses; be able to apply problem-solving knowledge and skills to write small, well-documented, effective C programs; be able to appreciate the use of simple data structure such as array, know their limitations to pave way for more complex data structures in the next course; know the responsibilities of an ethical programmer; be able to write simple programs in the corresponding programming language to solve a task, given the constraints on the inputs; be able to manually trace through a program to identify logical errors; be able to differentiate between logical errors, syntax errors, and run-time errors; be exposed informally to the concept of code specification in the form of comments in the code, explaining what are the expected inputs and outputs and what are the assumptions; know about what are some insecure functions to avoid; be able to generate test cases on their own, with a focus on boundary/special cases; be able to debug with printf or equivalent functions; be aware of common strategies and good practices of debugging with printf or equivalent functions; be able to identify opportunities to, and write, modularized code; be exposed to a debugger; be able to write code following good programming style (clear comments, naming convention, indentation, etc.); understand the different data types and that there exists a representation of each in the memory, as well as the limitation of the representations due to the limited number of bits; develop a simple mental model of how a program is executed (CPU runs the code on data that is stored in memory, function call leads to the creation of call frames, which can explain recursion and variable scoping, etc). For interpreted language, understand the role of virtual machine/interpreter; be able to understand at a high level the compilation process (from pre-processing to compiling to linking), where applicable; understand the concept of reusability and how a software application can be built on top of software libraries/packages (standard or third parties); be able to implement bubble sort and insertion sort; be able to implement linear search and binary search (both iterative and recursive versions);","title":"Learning Outcomes"},{"location":"policies.html","text":"Policies Email Communication Please use only your official NUS email for communication with the teaching staff -- either the one with @u.nus.edu or @comp.nus.edu.sg . Please use email only for private matters. Prefix your email subject with [CS1010] . Please use Piazza for other matters related to the module. If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate. Lab Sessions Attendance is not compulsory at NUS, but we do take attendance during the tutorial sessions. You should stick to your allocated time slot for tutorials. If there is a strong reason for you to attend another tutorial session, please inform your tutor. Late Submissions All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not). For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%. For example, if an assessment that was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached). Discussions and Plagiarism We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate. NUS and School of Computing have a high standard of academic honesty and take any violation seriously. In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation. Please read the page Preventing Plagiarism from the school's website to familiarize yourself with the policy. I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism. Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally. Screencast Screencast will be recorded and posted online 3-4 days after the lecture. This will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all. Posting of screencast is meant to help students who attended the lecture to recap the content or to help those who are not able to attend the lecture due to unexpected circumstances. It does not mean that you should skip the lecture. Research has shown that the effect of over-reliance on screencast is negative. Model Solutions and Slides Slides will be posted after the class. Note that slides are used as a visual aid to assist me during the lectures. It is not meant as a summary of lectures nor a replacement of lecture notes. In a module like CS1010, there is often not a single correct answer. Hence, there is no model solution for this module. Sample solutions may be posted (both good and bad ones) for discussion. I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution. Grading Students will receive the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve). In other words, the number of As and Fs will not be artificially capped. Open Book Assessment All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other analog reference materials. There is nothing to memorize for this class.","title":"Policies"},{"location":"policies.html#policies","text":"","title":"Policies"},{"location":"policies.html#email-communication","text":"Please use only your official NUS email for communication with the teaching staff -- either the one with @u.nus.edu or @comp.nus.edu.sg . Please use email only for private matters. Prefix your email subject with [CS1010] . Please use Piazza for other matters related to the module. If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.","title":"Email Communication"},{"location":"policies.html#lab-sessions","text":"Attendance is not compulsory at NUS, but we do take attendance during the tutorial sessions. You should stick to your allocated time slot for tutorials. If there is a strong reason for you to attend another tutorial session, please inform your tutor.","title":"Lab Sessions"},{"location":"policies.html#late-submissions","text":"All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not). For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%. For example, if an assessment that was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached).","title":"Late Submissions"},{"location":"policies.html#discussions-and-plagiarism","text":"We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate. NUS and School of Computing have a high standard of academic honesty and take any violation seriously. In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation. Please read the page Preventing Plagiarism from the school's website to familiarize yourself with the policy. I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism. Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.","title":"Discussions and Plagiarism"},{"location":"policies.html#screencast","text":"Screencast will be recorded and posted online 3-4 days after the lecture. This will be done on a 'best effort' basis and screencast will not be guaranteed to be available on time or at all. Posting of screencast is meant to help students who attended the lecture to recap the content or to help those who are not able to attend the lecture due to unexpected circumstances. It does not mean that you should skip the lecture. Research has shown that the effect of over-reliance on screencast is negative.","title":"Screencast"},{"location":"policies.html#model-solutions-and-slides","text":"Slides will be posted after the class. Note that slides are used as a visual aid to assist me during the lectures. It is not meant as a summary of lectures nor a replacement of lecture notes. In a module like CS1010, there is often not a single correct answer. Hence, there is no model solution for this module. Sample solutions may be posted (both good and bad ones) for discussion. I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.","title":"Model Solutions and Slides"},{"location":"policies.html#grading","text":"Students will receive the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve). In other words, the number of As and Fs will not be artificially capped.","title":"Grading"},{"location":"policies.html#open-book-assessment","text":"All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other analog reference materials. There is nothing to memorize for this class.","title":"Open Book Assessment"},{"location":"readings.html","text":"Readings Must Read How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio. Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again).. Best Teacher I Ever Had , by David Owen. Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, .. Why C? Learn C programming and the rest will come, by Marty Jacobs The Resurgence of C Programming, by Mark Barlow You Can't Dig Upwards, by Evan Miller Vim Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\" Vim Video Tutorial (from Aaron Tan) Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"Readings"},{"location":"readings.html#readings","text":"","title":"Readings"},{"location":"readings.html#must-read","text":"How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio. Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again).. Best Teacher I Ever Had , by David Owen. Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..","title":"Must Read"},{"location":"readings.html#why-c","text":"Learn C programming and the rest will come, by Marty Jacobs The Resurgence of C Programming, by Mark Barlow You Can't Dig Upwards, by Evan Miller","title":"Why C?"},{"location":"readings.html#vim","text":"Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\"","title":"Vim"},{"location":"readings.html#vim-video-tutorial-from-aaron-tan","text":"Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"Vim Video Tutorial (from Aaron Tan)"},{"location":"schedule.html","text":"Schedule This is the schedule for CS1010. Note: Assignments are released on Thursday and due the following Monday 23:59. Catch-up sessions are optional review + Q&A sessions meant for students who need time to recap and catch up. They are held on Saturday morning 10 am to 12noon Practical exams are held on Saturday morning from 9 am to 12noon The topics covered are tentative. Week Starting.. Topics Assignment Catch Up Session 1 2020-08-10 Computational Problem Solving 2 2020-08-17 Functions & Types 3 2020-08-24 Basic C programs CU1 4 2020-08-31 Conditionals AS1 5 2020-09-07 Loops AS2 6 2020-09-14 Memory, Array, Strings AS3 CU2 - 2020-09-21 Break 7 2020-09-28 Midterm PE1 AS4 8 2020-10-05 Call-by-Referece, nD-Array AS5 9 2020-10-12 Efficiency, Macro AS6 10 2020-10-19 Searching and Sorting AS7 CU3 11 2020-10-26 More recursion AS8 12 2020-11-02 Struct and I/O PE2 AS9 13 2020-11-09 Recap CU4","title":"Schedule"},{"location":"schedule.html#schedule","text":"This is the schedule for CS1010. Note: Assignments are released on Thursday and due the following Monday 23:59. Catch-up sessions are optional review + Q&A sessions meant for students who need time to recap and catch up. They are held on Saturday morning 10 am to 12noon Practical exams are held on Saturday morning from 9 am to 12noon The topics covered are tentative. Week Starting.. Topics Assignment Catch Up Session 1 2020-08-10 Computational Problem Solving 2 2020-08-17 Functions & Types 3 2020-08-24 Basic C programs CU1 4 2020-08-31 Conditionals AS1 5 2020-09-07 Loops AS2 6 2020-09-14 Memory, Array, Strings AS3 CU2 - 2020-09-21 Break 7 2020-09-28 Midterm PE1 AS4 8 2020-10-05 Call-by-Referece, nD-Array AS5 9 2020-10-12 Efficiency, Macro AS6 10 2020-10-19 Searching and Sorting AS7 CU3 11 2020-10-26 More recursion AS8 12 2020-11-02 Struct and I/O PE2 AS9 13 2020-11-09 Recap CU4","title":"Schedule"},{"location":"unix.html","text":"Basic UNIX Commands UNIX-based operating systems provide a command line to interact with the system: to create directories, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interact with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster. Connect to the Programming Environment (PE) If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and waits for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assume that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs in to the system. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. pwd : Print Current Working directory pwd shows you which directory you are currently in ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it. ls : LiSt files The ls list the files in the current working directory. ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first log in, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\") mkdir : MaKe a subDIRectory The mkdir command creates a subdirectory with the given name in the current directory. ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use ++control+p+ for Command History Unix maintains a history of your previously executed UNIX commands, and you may use ++control+p+ and Ctrl + N to go through it. Press the Ctrl + P until you find a previously executed UNIX command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long UNIX command. cd : Change Directory To navigate in the directory tree, changing the current working directory from to another, we use the cd command. ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return home, we can alternatively use cd .. . ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$ rmdir : ReMove a subDIRectory rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/ cp : CoPy files ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory. mv : MoVe or rename files mv can move files from one directory to another. ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy a file hello.c from the parent directory to the current directory. mv can also be used to rename files. ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: ooiwt@pe111:~/tut01$ mv h and press the Tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command. rm : ReMove files Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you set up your own UNIX OS, you should add this alias alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: alias mv = \"mv -i\" alias cp = \"cp -i\" cat : CATenate file content to the screen ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit. man : Online MANual An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article. chmod : Changing UNIX File Permission It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwxrwxrwx , or from -rwxr--r-- to rwxr-xr-x , and so on. You get the idea. Another way to change the permission is to set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: chmod 444 <file> To set the permission to -rw------- , run: chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises. scp : Secure Copy Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well. Specifying A Path in UNIX In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any shell you like if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"UNIX"},{"location":"unix.html#basic-unix-commands","text":"UNIX-based operating systems provide a command line to interact with the system: to create directories, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interact with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.","title":"Basic UNIX Commands"},{"location":"unix.html#connect-to-the-programming-environment-pe","text":"If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and waits for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assume that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs in to the system. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given.","title":"Connect to the Programming Environment (PE)"},{"location":"unix.html#pwd-print-current-working-directory","text":"pwd shows you which directory you are currently in ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it.","title":"pwd: Print Current Working directory"},{"location":"unix.html#ls-list-files","text":"The ls list the files in the current working directory. ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first log in, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\")","title":"ls: LiSt files"},{"location":"unix.html#mkdir-make-a-subdirectory","text":"The mkdir command creates a subdirectory with the given name in the current directory. ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use ++control+p+ for Command History Unix maintains a history of your previously executed UNIX commands, and you may use ++control+p+ and Ctrl + N to go through it. Press the Ctrl + P until you find a previously executed UNIX command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long UNIX command.","title":"mkdir: MaKe a subDIRectory"},{"location":"unix.html#cd-change-directory","text":"To navigate in the directory tree, changing the current working directory from to another, we use the cd command. ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return home, we can alternatively use cd .. . ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$","title":"cd: Change Directory"},{"location":"unix.html#rmdir-remove-a-subdirectory","text":"rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/","title":"rmdir: ReMove a subDIRectory"},{"location":"unix.html#cp-copy-files","text":"ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory.","title":"cp: CoPy files"},{"location":"unix.html#mv-move-or-rename-files","text":"mv can move files from one directory to another. ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy a file hello.c from the parent directory to the current directory. mv can also be used to rename files. ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: ooiwt@pe111:~/tut01$ mv h and press the Tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command.","title":"mv: MoVe or rename files"},{"location":"unix.html#rm-remove-files","text":"Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you set up your own UNIX OS, you should add this alias alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: alias mv = \"mv -i\" alias cp = \"cp -i\"","title":"rm: ReMove files"},{"location":"unix.html#cat-catenate-file-content-to-the-screen","text":"ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit.","title":"cat: CATenate file content to the screen"},{"location":"unix.html#man-online-manual","text":"An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.","title":"man: Online MANual"},{"location":"unix.html#chmod-changing-unix-file-permission","text":"It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwxrwxrwx , or from -rwxr--r-- to rwxr-xr-x , and so on. You get the idea. Another way to change the permission is to set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: chmod 444 <file> To set the permission to -rw------- , run: chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.","title":"chmod: Changing UNIX File Permission"},{"location":"unix.html#scp-secure-copy","text":"Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well.","title":"scp: Secure Copy"},{"location":"unix.html#specifying-a-path-in-unix","text":"In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any shell you like if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"Specifying A Path in UNIX"},{"location":"vim.html","text":"Vim Tips I collected some tips on vim that I find helpful. If you are new to vim , please try out the command vimtutor on any machine where vim is installed, and check out the nice article Learn vim Progressively . 1. Useful Configuration You can configure your vim by putting your configuration options and scripts in the ~/.vimrc file (a hidden file named .vimrc in your home directory). This file will be loaded whenever you start vim . You can copy a sample .vimrc file from ~cs1010/.vimrc to your home directory. You can edit this file ~/.vimrc just like any other file, using vim . Help In vim, the command :help <topic> shows help about a particular topic in vim . Example, :help backup . Backup Files You can ask vim to automatically backup files that you edit. This has been a lifesaver for me on multiple occasions. In your ~/.vimrc file, set backup will cause a copy of your file to be saved with suffix ~ appended to its name every time you save. I prefer not to clutter my working directory, so I set set backupdir=~/.backup and create a directory named ~/.backup to store my backup files. So if you made changes to a file that you regretted, or if you accidentally deleted a file, you can check under ~/.backup to see if the backup can save you. Syntax Highlighting If for some reasons, syntax highlighting is not on by default, add this to your ~/.vimrc : syntax on Ruler and Numbers If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc set ruler will display the line number and the column number on the lower right corner. You can also add set number to label each line with a line number. Auto Indentation Proper indentation is important to make your code readable (to yourself and others). You should enable this in vim with: set autoindent set smartindent Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing { and } ) and indent your code accordingly. The size of the indentation is based on the setting shiftwidth . For CS1010, please set it to either 2 or 4 : set shiftwidth=2 2. Navigation Basic Navigation Use k and j keys to move up and down (just like Gmail and Facebook!). h and l to move left and right. Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many hjkl to see how you can navigate faster). w jump to the beginning of the next word b jump to the beginning of the previous word (reverse of w ) e jump to the end of the word (or next word when pressed again) f + char: search forward in the line and sit on the next matching char t + char: search forward in the line and sit on one space before the matching char $ jump to the end of line 0 jump to the beginning of the line ^ jump to the first non-blank character of the line % jump between matching parentheses CTRL- d jump forward (Down) half page CTRL- f jump Forward one page CTRL- u jump backward (Up) half page CTRL- b jump Backward half page Jumping to a Line If the compiler tells you there is an error on Line x x , you can issue :<x> to jump to Line x x . For instance, :40 will go to Line 40. 3. Editing Operations Undo Since we are on the topic of correcting mistakes, u in command mode undo your changes. Prefix it with a number n n to undo n n times. If you want to undo your undo, <CTRL-R> will redo. Navigation + Editing vim is powerful because you can combine operations with navigation . For instance c to change, d to delete, y to yank (copy). Since w is the navigation command to move over the current word, combining them we get: cw change the current word (delete the current word and enter insert mode) dw delete the current word yw yank the current word (copy word into buffer) Can you guess what df) , dt) , c$ , y0 do? If you repeat the operation c , d , and y , it applies to the whole line, so: cc change the whole line dd delete the whole line yy yank the whole line You can add a number before an operation to specify how many times you want to repeat an operation. So 5dd deletes 5 lines, 5dw deletes 5 words, etc. See the article Operator, the True Power of Vim for more details. Swapping Lines Sometimes you want to swap the order of two lines of code, in command mode, ddp will do the trick. dd deletes the current line, p paste it after the current line, in effect swapping the order of the two lines. Commenting blocks of code Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in vim : Place the cursor on the first line of the block of code you want to comment on. 0 to jump to the beginning of the line V enter visual mode Use the arrow key to select the block of code you want to comment on. I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected) // to insert the Java comment character (you will see it inserted in the current line, but don't worry) to escape from the visual code. To uncomment, Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line <CTRL-v> enter block visual mode Use the arrow key to select the columns of text containing // x to delete them 4. Other Advanced Features Search and Replace in vim :%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurrence of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement Shell Command If you need to issue a shell command quickly, you don't have to exit vim , run the command, and launch vim again. You can use ! , :!<command> will issue the command to shell. E.g., :!ls You can use this to compile your current file, without exiting vim . :!make make is actually a builtin command for vim so you can also simply run :make Abbreviation You can use the command ab to abbreviate frequently typed commands. E.g., in your ~/.vimrc , ab pl cs1010_print_long( Now, when you type pl , it will be expanded into cs1010_print_long( Auto-Completion You can <CTRL-P> to auto-complete. By default, the autocomplete dictionary is based on the text in your current editing buffers. This is a very useful keystroke saver for long function and variable names. Auto-Indent the Whole File You can gg=G in command mode to auto-indent the whole file. gg is the command to go to the beginning of the file. = is the command to indent. G is the command to go to the end of the file. Splitting vim 's Viewport :sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl-w Ctrl-w moves between the different vim viewports 5. Plugins Syntax and Style Checker I use syntastic to check for style and syntax whenever I save a file. syntastic is a vim plugin. My .vimrc configuration file contains the following: \"For syntastic set laststatus=2 set statusline+=%#warningmsg# set statusline+=%{SyntasticStatuslineFlag()} set statusline+=%* let g:syntastic_error_symbol = '\u2717' let g:syntastic_warning_symbol = '\u26a0' let g:syntastic_always_populate_loc_list = 1 let g:syntastic_auto_loc_list = 1 let g:syntastic_check_on_open = 1 let g:syntastic_check_on_wq = 0 let g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ] let g:syntastic_c_compiler = 'clang' let g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude' let g:syntastic_c_clang_tidy_args = '-checks=*' let g:syntastic_c_compiler_options = '-Wall -Iinclude' let g:syntastic_c_include_dirs = [ '../include', 'include' ] let g:syntastic_c_clang_tidy_post_args = \"\" By default, clang-tidy does not know where to find the header files. So if you include non-standard C headers, it will complain that it cannot find headers. To resolve this, we need to tell clang-tidy the compilation flags that we use when compiling our program. We can do this by creating a file named compile_flags.txt in your working directory (where your C files are located), containing one compilation flag per line. For instance, if the header files are located in /home/course/cs1010/include , your compile_flags.txt should contain the following two lines: -Wall -I/home/course/cs1010/include","title":"Vim"},{"location":"vim.html#vim-tips","text":"I collected some tips on vim that I find helpful. If you are new to vim , please try out the command vimtutor on any machine where vim is installed, and check out the nice article Learn vim Progressively .","title":"Vim Tips"},{"location":"vim.html#1-useful-configuration","text":"You can configure your vim by putting your configuration options and scripts in the ~/.vimrc file (a hidden file named .vimrc in your home directory). This file will be loaded whenever you start vim . You can copy a sample .vimrc file from ~cs1010/.vimrc to your home directory. You can edit this file ~/.vimrc just like any other file, using vim .","title":"1. Useful Configuration"},{"location":"vim.html#help","text":"In vim, the command :help <topic> shows help about a particular topic in vim . Example, :help backup .","title":"Help"},{"location":"vim.html#backup-files","text":"You can ask vim to automatically backup files that you edit. This has been a lifesaver for me on multiple occasions. In your ~/.vimrc file, set backup will cause a copy of your file to be saved with suffix ~ appended to its name every time you save. I prefer not to clutter my working directory, so I set set backupdir=~/.backup and create a directory named ~/.backup to store my backup files. So if you made changes to a file that you regretted, or if you accidentally deleted a file, you can check under ~/.backup to see if the backup can save you.","title":"Backup Files"},{"location":"vim.html#syntax-highlighting","text":"If for some reasons, syntax highlighting is not on by default, add this to your ~/.vimrc : syntax on","title":"Syntax Highlighting"},{"location":"vim.html#ruler-and-numbers","text":"If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc set ruler will display the line number and the column number on the lower right corner. You can also add set number to label each line with a line number.","title":"Ruler and Numbers"},{"location":"vim.html#auto-indentation","text":"Proper indentation is important to make your code readable (to yourself and others). You should enable this in vim with: set autoindent set smartindent Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing { and } ) and indent your code accordingly. The size of the indentation is based on the setting shiftwidth . For CS1010, please set it to either 2 or 4 : set shiftwidth=2","title":"Auto Indentation"},{"location":"vim.html#2-navigation","text":"","title":"2. Navigation"},{"location":"vim.html#basic-navigation","text":"Use k and j keys to move up and down (just like Gmail and Facebook!). h and l to move left and right. Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many hjkl to see how you can navigate faster). w jump to the beginning of the next word b jump to the beginning of the previous word (reverse of w ) e jump to the end of the word (or next word when pressed again) f + char: search forward in the line and sit on the next matching char t + char: search forward in the line and sit on one space before the matching char $ jump to the end of line 0 jump to the beginning of the line ^ jump to the first non-blank character of the line % jump between matching parentheses CTRL- d jump forward (Down) half page CTRL- f jump Forward one page CTRL- u jump backward (Up) half page CTRL- b jump Backward half page","title":"Basic Navigation"},{"location":"vim.html#jumping-to-a-line","text":"If the compiler tells you there is an error on Line x x , you can issue :<x> to jump to Line x x . For instance, :40 will go to Line 40.","title":"Jumping to a Line"},{"location":"vim.html#3-editing-operations","text":"","title":"3. Editing Operations"},{"location":"vim.html#undo","text":"Since we are on the topic of correcting mistakes, u in command mode undo your changes. Prefix it with a number n n to undo n n times. If you want to undo your undo, <CTRL-R> will redo.","title":"Undo"},{"location":"vim.html#navigation-editing","text":"vim is powerful because you can combine operations with navigation . For instance c to change, d to delete, y to yank (copy). Since w is the navigation command to move over the current word, combining them we get: cw change the current word (delete the current word and enter insert mode) dw delete the current word yw yank the current word (copy word into buffer) Can you guess what df) , dt) , c$ , y0 do? If you repeat the operation c , d , and y , it applies to the whole line, so: cc change the whole line dd delete the whole line yy yank the whole line You can add a number before an operation to specify how many times you want to repeat an operation. So 5dd deletes 5 lines, 5dw deletes 5 words, etc. See the article Operator, the True Power of Vim for more details.","title":"Navigation + Editing"},{"location":"vim.html#swapping-lines","text":"Sometimes you want to swap the order of two lines of code, in command mode, ddp will do the trick. dd deletes the current line, p paste it after the current line, in effect swapping the order of the two lines.","title":"Swapping Lines"},{"location":"vim.html#commenting-blocks-of-code","text":"Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in vim : Place the cursor on the first line of the block of code you want to comment on. 0 to jump to the beginning of the line V enter visual mode Use the arrow key to select the block of code you want to comment on. I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected) // to insert the Java comment character (you will see it inserted in the current line, but don't worry) to escape from the visual code. To uncomment, Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line <CTRL-v> enter block visual mode Use the arrow key to select the columns of text containing // x to delete them","title":"Commenting blocks of code"},{"location":"vim.html#4-other-advanced-features","text":"","title":"4. Other Advanced Features"},{"location":"vim.html#search-and-replace-in-vim","text":":%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurrence of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement","title":"Search and Replace in vim"},{"location":"vim.html#shell-command","text":"If you need to issue a shell command quickly, you don't have to exit vim , run the command, and launch vim again. You can use ! , :!<command> will issue the command to shell. E.g., :!ls You can use this to compile your current file, without exiting vim . :!make make is actually a builtin command for vim so you can also simply run :make","title":"Shell Command"},{"location":"vim.html#abbreviation","text":"You can use the command ab to abbreviate frequently typed commands. E.g., in your ~/.vimrc , ab pl cs1010_print_long( Now, when you type pl , it will be expanded into cs1010_print_long(","title":"Abbreviation"},{"location":"vim.html#auto-completion","text":"You can <CTRL-P> to auto-complete. By default, the autocomplete dictionary is based on the text in your current editing buffers. This is a very useful keystroke saver for long function and variable names.","title":"Auto-Completion"},{"location":"vim.html#auto-indent-the-whole-file","text":"You can gg=G in command mode to auto-indent the whole file. gg is the command to go to the beginning of the file. = is the command to indent. G is the command to go to the end of the file.","title":"Auto-Indent the Whole File"},{"location":"vim.html#splitting-vims-viewport","text":":sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl-w Ctrl-w moves between the different vim viewports","title":"Splitting vim's Viewport"},{"location":"vim.html#5-plugins","text":"","title":"5. Plugins"},{"location":"vim.html#syntax-and-style-checker","text":"I use syntastic to check for style and syntax whenever I save a file. syntastic is a vim plugin. My .vimrc configuration file contains the following: \"For syntastic set laststatus=2 set statusline+=%#warningmsg# set statusline+=%{SyntasticStatuslineFlag()} set statusline+=%* let g:syntastic_error_symbol = '\u2717' let g:syntastic_warning_symbol = '\u26a0' let g:syntastic_always_populate_loc_list = 1 let g:syntastic_auto_loc_list = 1 let g:syntastic_check_on_open = 1 let g:syntastic_check_on_wq = 0 let g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ] let g:syntastic_c_compiler = 'clang' let g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude' let g:syntastic_c_clang_tidy_args = '-checks=*' let g:syntastic_c_compiler_options = '-Wall -Iinclude' let g:syntastic_c_include_dirs = [ '../include', 'include' ] let g:syntastic_c_clang_tidy_post_args = \"\" By default, clang-tidy does not know where to find the header files. So if you include non-standard C headers, it will complain that it cannot find headers. To resolve this, we need to tell clang-tidy the compilation flags that we use when compiling our program. We can do this by creating a file named compile_flags.txt in your working directory (where your C files are located), containing one compilation flag per line. For instance, if the header files are located in /home/course/cs1010/include , your compile_flags.txt should contain the following two lines: -Wall -I/home/course/cs1010/include","title":"Syntax and Style Checker"}]}