{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Announcements Getting Ready for CS1010 Welcome to CS1010! Here are some things that you can do while waiting for the semester to start. Take a Look at General CS1010 Information Take a look at the crucial information about CS1010 here. Scan through the learning outcomes to know what you are expected to learn in this module. Note down the important dates on your calendar. Read about CS1010 Policies The general policies for CS1010 is posted. Go through it to see what is expected. Enable Your Piazza Account You should have received an email inviting you to create a Piazza account and enroll in the module Q&A forum. Please join CS1010 on Piazza. Enable Your SoC Account Go to https://mysoc.nus.edu.sg/~newacct and create your SoC Unix Account if you have not done so. Activate \"General Unix Servers\" and \"The SoC Compute Cluster\" in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi Create a GitHub Account Create a GitHub account if you do not have one. This account should stay with you for your professional career. So choose the username wisely. Then, tells us your GitHub Username here before 13 August 2021, Friday. Get a Head-Start with Unix and Vim You can check out the content for SoC Unix@Home Workshop , which was held last year. The website contains notes with examples, which you can follow through. If you have questions or face any issues, ask on Piazza. You can also find more notes under \"Software/Tools\". Read Feedback on CS1010 from Last Year Ago This semester's CS1010 will be conducted in a similar style with the version in AY2020/21. Read the comments from that batch of students to know what to expect. Explore Some Additional Readings Some extra reading materials curated by Wei Tsang are available . If you have some programming background and are wondering why we are teaching C, read the articles under Why C section.","title":"Home"},{"location":"index.html#announcements","text":"Getting Ready for CS1010 Welcome to CS1010! Here are some things that you can do while waiting for the semester to start. Take a Look at General CS1010 Information Take a look at the crucial information about CS1010 here. Scan through the learning outcomes to know what you are expected to learn in this module. Note down the important dates on your calendar. Read about CS1010 Policies The general policies for CS1010 is posted. Go through it to see what is expected. Enable Your Piazza Account You should have received an email inviting you to create a Piazza account and enroll in the module Q&A forum. Please join CS1010 on Piazza. Enable Your SoC Account Go to https://mysoc.nus.edu.sg/~newacct and create your SoC Unix Account if you have not done so. Activate \"General Unix Servers\" and \"The SoC Compute Cluster\" in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi Create a GitHub Account Create a GitHub account if you do not have one. This account should stay with you for your professional career. So choose the username wisely. Then, tells us your GitHub Username here before 13 August 2021, Friday. Get a Head-Start with Unix and Vim You can check out the content for SoC Unix@Home Workshop , which was held last year. The website contains notes with examples, which you can follow through. If you have questions or face any issues, ask on Piazza. You can also find more notes under \"Software/Tools\". Read Feedback on CS1010 from Last Year Ago This semester's CS1010 will be conducted in a similar style with the version in AY2020/21. Read the comments from that batch of students to know what to expect. Explore Some Additional Readings Some extra reading materials curated by Wei Tsang are available . If you have some programming background and are wondering why we are teaching C, read the articles under Why C section.","title":"Announcements"},{"location":"01-program.html","text":"Unit 1: What is a Program? Learning Outcomes After this unit, students should: have an idea of what is a program and how a program is executed by a computer understand the basic terminologies: machine code, assembly language, and higher-level programming languages What is a (computer) program? Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task. Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010. How computer executes a program In order to learn how to write a program, it is important to have an overview of how a computer executes a program. You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process. The two important components of a computer we will discuss for CS1010 is the CPU, or central processing unit and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so. A memory location is addressable using a memory address . The instructions to the CPU comes in the form of machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things. These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location. The data stored in the memory is also stored as a sequence of 1s and 0s. From Machine Code to High-level Programming Language While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this location is actually determined by the operating system). The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human. Simple operations such as comparing two numbers to see which one is bigger might require several instructions to perform. To get around the readability problem, programmers can code in assembly language -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as decr , incr , store , add , etc.) Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming. Early programmers (in the fifties) understood this and designed high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent. A program written in one of these programming languages is then compiled into machine code for a specific CPU for execution using a compiler. The first commercially available language is FORTRAN from IBM in the 1950s. Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today, For many reasons , C is the language of choice for CS1010. The Goals of CS1010 This brings us to the goals of CS1010. First, you will learn the most important syntax element of the C programming language. Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory. Third, you will learn the various tools and techniques that will help you produce good and correct C programs. The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems. Learning to write a program that does what you want it to do is actually not difficult. Knowing what you want your program to do is the more challenging part!","title":"1. What is a Program?"},{"location":"01-program.html#unit-1-what-is-a-program","text":"","title":"Unit 1: What is a Program?"},{"location":"01-program.html#learning-outcomes","text":"After this unit, students should: have an idea of what is a program and how a program is executed by a computer understand the basic terminologies: machine code, assembly language, and higher-level programming languages","title":"Learning Outcomes"},{"location":"01-program.html#what-is-a-computer-program","text":"Despite all the wonderful and amazing things that computers can do, computers are not very smart. In fact, they are pretty dumb. Computers can only follow the instructions given by a human. A computer program is a sequence of step-by-step instructions given to computers to manipulate data in order to perform a certain task. Programming is the art and science of writing a computer program, and that is what you will learn to do in CS1010.","title":"What is a (computer) program?"},{"location":"01-program.html#how-computer-executes-a-program","text":"In order to learn how to write a program, it is important to have an overview of how a computer executes a program. You will learn in details how this is done in CS2100/CS2106 or EE2024/CG2271, but for CS1010, we will take a very simplistic and high-level view of this process. The two important components of a computer we will discuss for CS1010 is the CPU, or central processing unit and the memory, which is a generalized term for where we store the data to be processed or manipulated by the CPU, as well as the instructions to do so. A memory location is addressable using a memory address . The instructions to the CPU comes in the form of machine code , a sequence of bits (1s and 0s) that is interpreted and then followed by the CPU to do certain things. These machine code could instruct the CPU, for instance, to compare if a particular number at a certain memory location is more than 0, to add one number to another, or to execute another instruction at another memory location. The data stored in the memory is also stored as a sequence of 1s and 0s.","title":"How computer executes a program"},{"location":"01-program.html#from-machine-code-to-high-level-programming-language","text":"While it is possible for us, human, to write machine code directly, few actually do since it is challenging to do so. Different CPUs understand different sets of machine code; it is tedious to figure out where each piece of data is located in the memory (this location is actually determined by the operating system). The resulting code, even when it is correct and easy to read and understand by the machine, are often hard to decipher for a human. Simple operations such as comparing two numbers to see which one is bigger might require several instructions to perform. To get around the readability problem, programmers can code in assembly language -- a human-readable form of machine code, where each instruction, instead of represented by 0s and 1s, is represented by a mnemonic (such as decr , incr , store , add , etc.) Writing assembly code does not address the issues of machine-dependent code and the tediousness of programming. Early programmers (in the fifties) understood this and designed high-level programming languages , where programmers can describe the operations that they wish to do in a language closer to their intention that is machine independent. A program written in one of these programming languages is then compiled into machine code for a specific CPU for execution using a compiler. The first commercially available language is FORTRAN from IBM in the 1950s. Among many early programming languages, C (birth year 1972) is the only one that is still popular and widely used today, For many reasons , C is the language of choice for CS1010.","title":"From Machine Code to High-level Programming Language"},{"location":"01-program.html#the-goals-of-cs1010","text":"This brings us to the goals of CS1010. First, you will learn the most important syntax element of the C programming language. Second, you will learn how a C program behaves, in relation to how a program is executed and how data are stored and manipulated in memory. Third, you will learn the various tools and techniques that will help you produce good and correct C programs. The last, and the most important and challenging goal of CS1010, however, is that you will learn how to write programs to solve computational problems. Learning to write a program that does what you want it to do is actually not difficult. Knowing what you want your program to do is the more challenging part!","title":"The Goals of CS1010"},{"location":"02-algo.html","text":"Unit 2: Computational Problems and Algorithms Learning Outcomes: After this unit, students should: be able to differentiate between a computational and a non-computational problem; understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment; be familiar with the algorithm to find the maximum among a list of numbers; be able to express an algorithm using a flowchart; be able to trace through flowcharts that involves branching, looping, and updates of variables; understand the notion of the \"correctness\" of an algorithm. Computational Problems So, what is computational problem solving? Let's start with the question, what is a computational problem ? A computational problem is a problem that can be solved step-by-step with a computer. These problems usually have a well-defined input, constraints, and conditions that the output must satisfied. Here are some types of computational problems: A decision problem is one where the answer is yes or no. For instance, \"given a number \\(n\\) , is \\(n\\) even?\" is a decision problem. Some decision problems take more steps to solve than others. For instance, \"given a number \\(n\\) , is \\(n\\) prime?\" takes more steps than just checking the parity of a number. A search problem is one where the solution consists of one or more values that satisfies a given condition. For instance, we may want to compute a path from one geographical location to another on a map. A counting problem is one where the answer is the number of solutions to a search problem. An optimization problem is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way. For instance, we may want to compute the fastest route from one location to another. Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1 are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy. In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems computationally -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem. Example: Finding the maximum Let's start with a simple problem. Given a finite list \\(L\\) of \\(k\\) integers ( \\(k\\) > 0), find the maximum integer from the list. First, let's consider if this is a computational problem. The input is very well defined. We know what an integer is. We are told we have at least one, and we have a finite number of them 2 . Second, let's consider the output. What conditions must the output satisfy? First, it has to be equal or larger than every other integer on the list. Second, it must be an integer in the list. This is well defined by the problem statement, so we can say that it is a computational problem. Here is an example. Suppose the input consists of: 4 1 -4 0 9 9 3 5 8 The output should be 9 . Now, you should pause reading and think about how you would solve this step-by-step. Algorithm One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far. When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list. Let's look at an example: Integers Scanned Maximum So Far 4 4 4 1 4 4 1 -4 4 4 1 -4 0 4 4 1 -4 0 9 9 4 1 -4 0 9 9 9 4 1 -4 0 9 9 3 9 4 1 -4 0 9 9 3 5 9 4 1 -4 0 9 9 3 5 8 9 The English description above, however, is not detailed enough for computers to understand. What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"? how to tell if we have reached \"the end of the list\"? Let's work out all the details. First, we need a concise way of representing the integers in the list. Borrowing from mathematical notation, let's say that the list \\(L\\) contains the integers \\(\\langle l_0, l_1, ..., l_{k-1} \\rangle\\) . To \"check one-by-one,\" we introduce another notation \\(l_i\\) , which is the integer currently being \"checked\". We begin with \\(i = 0\\) , then \\(i = 1\\) , then \\(i = 2\\) , etc, until \\(i = k-1\\) . At every step, we increase \\(i\\) by 1. Second, we need a concise way of keeping track of the maximum so far. We introduce another notation, \\(m\\) , to represent the maximum value so far. When \\(i = 0\\) , \\(m = l_0\\) . Since we only scan a single integer, it has to be the maximum. When we check another integer \\(l_i (i > 0)\\) , only two things can happen: if this \\(l_i\\) is larger than \\(m\\) , then \\(l_i\\) has to be the maximum so far, so we update \\(m\\) to be \\(l_i\\) . if \\(l_i\\) is equal to or smaller than \\(m\\) , then \\(m\\) is still the maximum value so far. We keep doing the above and increase \\(i\\) , until we reach the end of the list when (after increasing \\(i\\) ) we find that \\(i\\) is \\(k\\) . Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers. Such steps, which the computer can take to solve a problem, is called an algorithm . Flowchart There are different ways one can describe an algorithm. The easiest way I find is to use a diagram called a flowchart . The flowchart for the algorithm above looks like this. There are several components to a flowchart. We will use the following convention in CS1010: An arrow indicates the direction of the flow, i.e., what is the next step of the algorithm. A rounded rectangle denotes either the starting (inputs) or ending point (output) of the algorithm. A diamond box represents a \"question\" that can be true or false (yes or no). It indicates a \"branch\" in the flow. Which branch we follow is deteremined the answer to the question in the box. A rectangle represents one or more \"operations\" (such as initialization or manipulation of data) To understand the flowchart above, let's trace through it with the sample input. We will maintain the following table as we trace through the flowchart. At the beginning, just before entering \" \\(i\\) equals \\(k\\) ?\", we have the following: Integers Scanned \\(i\\) \\(l_i\\) \\(k\\) Maximum So Far ( \\(m\\) ) 4 1 1 9 4 Subsequently, we enter a \"loop\", and the values assigned to the symbols at the point after \" \\(i\\) equals \\(k\\) ?\" can be traced as follows: Integers Scanned \\(i\\) \\(l_i\\) \\(k\\) Maximum So Far ( \\(m\\) ) 4 1 1 1 9 4 4 1 -4 2 -4 9 4 4 1 -4 0 3 0 9 4 4 1 -4 0 9 4 9 9 4 4 1 -4 0 9 9 5 9 9 9 4 1 -4 0 9 9 3 6 3 9 9 4 1 -4 0 9 9 3 5 7 5 9 9 4 1 -4 0 9 9 3 5 8 8 8 9 9 4 1 -4 0 9 9 3 5 8 9 `` 9 9 Please spend some time to trace through the flowchart above. Variables There are a few important things to take note here. \\(m\\) , \\(i\\) , \\(k\\) , and the list \\(L\\) are what we called states or variables . While in the above, we can think of them as mathematical variables which we can assign values to, in a computer program, a variable is a location in the memory which holds a value. We can perform two very basic operations on the variables: reading and writing. In other words, we can set their values and we can retrieve their values. We can assign the value of one variable to a constant (e.g., set \\(i\\) to 1) or to the value of another variable (e.g., set \\(m\\) to \\(l_i\\) ). In the latter example, we first read the value of \\(l_i\\) , from \\(l_i\\) 's memory location and then we write that value to the memory location of \\(m\\) . Once written, the value of \\(m\\) will not change until the next time we update the value of \\(m\\) . It is important to note that, when \\(i\\) changes, \\(m\\) does not change automatically to the new \\(l_i\\) This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say A1 to be =B1 , when the value in cell B1 changes, the value A1 also changes automatically. We can also compare the values of two variables. We see two examples above: \" \\(i\\) equals \\(k\\) ?\" \" \\(l_i > m\\) ?\" When we compare, we read the values of the variables from their memory location and checks their relations. We can perform arithmetic operations on the variables: addition, subtraction, etc. We see one example above: \"increment \\(i\\) \". This operation is actually an assignment operation in disguise. We can write it as \"set \\(i\\) to \\(i\\) + 1\". Here, you see that \\(i\\) is referred to twice. This operation reads the value from the memory location of \\(i\\) , adds 1 to it, and then writes the resulting value back to the location of \\(i\\) . Bugs If you follow the execution of the algorithm above, step-by-step, using the example input 4 1 -4 0 9 9 3 5 above, you will obtain the correct maximum value \\(m\\) of 9 . But does that mean that the algorithm is correct? The answer is NO. For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem. If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect. Note that I say does not produce the correct output , which means that either the algorithm produces the wrong output or does not produce any output at all . In this case, we say that the algorithm or the program has a bug . A bug is a defect that causes the algorithm to behave incorrectly. As a software developer, you will spend some time finding bugs in your code, a process known as debugging . A debugger is a tool that helps programmers find bugs in their code. Before we even start the process of debugging, we first have to know if our algorithm is correct. Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs. So, one way to check if an algorithm is correct is to try it with all possible valid inputs. For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs. In practice, we craft a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and hope that it is correct for all possible inputs. With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code. There are also systematic ways of deriving test cases so that the test cases cover different paths of execution of the algorithm, but we won't be covering it in CS1010 3 . Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm. We will do this rather informally in CS1010, starting in 1-2 lectures from now. You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms). Finally, even if an algorithm is correct, the corresponding program might not be. Recall that an algorithm is a step-by-step process to solve a problem. It is what you want your program to do. You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to implement the algorithm ). This process of translating the algorithm to a computer program, called coding may introduce bugs as well. But we will worry about this later when we learn to program. In the problem set at the end of this lecture, you will see slight variations of the algorithm above. You should check through them to see whether they are correct or not. Problem Set Problem 1.1 The following algorithms are slight variations of the one in the notes above. The differences are highlighted in red. Do they correctly find the maximum integer from a finite list of \\(k\\) integers ( \\(k > 0\\) )? If an algorithm is buggy, give a counter-example where the output is incorrect. In addition, give an example input where the algorithm still produces the correct output, where possible. (a) (b) (c) (d) (e) Problem 1.2 Change the algorithm above to find the minimum value instead of the maximum value from the given list \\(L = \\langle l_0, ..., l_{k-1}\\rangle\\) . You can also assume that the list \\(L\\) is finite and \\(k > 0\\) for this question. Problem 1.3 Draw the flowchart for an algorithm, that takes in a list of integers \\(L = \\langle l_0, ..., l_{k-1}\\rangle, k > 0\\) , and compute the sum of all the integers. Think about what variable(s) do you need. The answer is, by the way, always \"Yes.\" \u21a9 Think about why it is important to have a finite number of integers in the input. \u21a9 Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218. \u21a9","title":"2. Computational Problem & Algorithms"},{"location":"02-algo.html#unit-2-computational-problems-and-algorithms","text":"","title":"Unit 2: Computational Problems and Algorithms"},{"location":"02-algo.html#learning-outcomes","text":"After this unit, students should: be able to differentiate between a computational and a non-computational problem; understand the basic terminologies: computational problem solving, algorithm, flowchart, debugging, testing, variables, value, assignment; be familiar with the algorithm to find the maximum among a list of numbers; be able to express an algorithm using a flowchart; be able to trace through flowcharts that involves branching, looping, and updates of variables; understand the notion of the \"correctness\" of an algorithm.","title":"Learning Outcomes:"},{"location":"02-algo.html#computational-problems","text":"So, what is computational problem solving? Let's start with the question, what is a computational problem ? A computational problem is a problem that can be solved step-by-step with a computer. These problems usually have a well-defined input, constraints, and conditions that the output must satisfied. Here are some types of computational problems: A decision problem is one where the answer is yes or no. For instance, \"given a number \\(n\\) , is \\(n\\) even?\" is a decision problem. Some decision problems take more steps to solve than others. For instance, \"given a number \\(n\\) , is \\(n\\) prime?\" takes more steps than just checking the parity of a number. A search problem is one where the solution consists of one or more values that satisfies a given condition. For instance, we may want to compute a path from one geographical location to another on a map. A counting problem is one where the answer is the number of solutions to a search problem. An optimization problem is one where the solution is the \"best\" possible solution, where the \"best\" can be defined in a different way. For instance, we may want to compute the fastest route from one location to another. Questions such as \"what is the meaning of life?\" \"do I look good in this outfit?\" 1 are not computational problems, because they do not have well-defined input, constraints, and conditions that the output must satisfy. In CS1010 (followed by CS2040C and CS3230), you will learn how to solve computational problems computationally -- this means that you learn to come up with step-by-step instructions meant for computers that you can translate into computer programs, to solve a given problem.","title":"Computational Problems"},{"location":"02-algo.html#example-finding-the-maximum","text":"Let's start with a simple problem. Given a finite list \\(L\\) of \\(k\\) integers ( \\(k\\) > 0), find the maximum integer from the list. First, let's consider if this is a computational problem. The input is very well defined. We know what an integer is. We are told we have at least one, and we have a finite number of them 2 . Second, let's consider the output. What conditions must the output satisfy? First, it has to be equal or larger than every other integer on the list. Second, it must be an integer in the list. This is well defined by the problem statement, so we can say that it is a computational problem. Here is an example. Suppose the input consists of: 4 1 -4 0 9 9 3 5 8 The output should be 9 . Now, you should pause reading and think about how you would solve this step-by-step.","title":"Example: Finding the maximum"},{"location":"02-algo.html#algorithm","text":"One way to solve this problem is to check through the integers in the list, one-by-one, and keep track of the maximum value so far. When you reach the end of the list, your \"maximum value so far\" will also be the maximum for the whole list. Let's look at an example: Integers Scanned Maximum So Far 4 4 4 1 4 4 1 -4 4 4 1 -4 0 4 4 1 -4 0 9 9 4 1 -4 0 9 9 9 4 1 -4 0 9 9 3 9 4 1 -4 0 9 9 3 5 9 4 1 -4 0 9 9 3 5 8 9 The English description above, however, is not detailed enough for computers to understand. What is the meaning of \"check one-by-one\"? \"keep track of maximum so far\"? how to tell if we have reached \"the end of the list\"? Let's work out all the details. First, we need a concise way of representing the integers in the list. Borrowing from mathematical notation, let's say that the list \\(L\\) contains the integers \\(\\langle l_0, l_1, ..., l_{k-1} \\rangle\\) . To \"check one-by-one,\" we introduce another notation \\(l_i\\) , which is the integer currently being \"checked\". We begin with \\(i = 0\\) , then \\(i = 1\\) , then \\(i = 2\\) , etc, until \\(i = k-1\\) . At every step, we increase \\(i\\) by 1. Second, we need a concise way of keeping track of the maximum so far. We introduce another notation, \\(m\\) , to represent the maximum value so far. When \\(i = 0\\) , \\(m = l_0\\) . Since we only scan a single integer, it has to be the maximum. When we check another integer \\(l_i (i > 0)\\) , only two things can happen: if this \\(l_i\\) is larger than \\(m\\) , then \\(l_i\\) has to be the maximum so far, so we update \\(m\\) to be \\(l_i\\) . if \\(l_i\\) is equal to or smaller than \\(m\\) , then \\(m\\) is still the maximum value so far. We keep doing the above and increase \\(i\\) , until we reach the end of the list when (after increasing \\(i\\) ) we find that \\(i\\) is \\(k\\) . Now, we have enough details to describe step-by-step, how to find the maximum value from a list of integers. Such steps, which the computer can take to solve a problem, is called an algorithm .","title":"Algorithm"},{"location":"02-algo.html#flowchart","text":"There are different ways one can describe an algorithm. The easiest way I find is to use a diagram called a flowchart . The flowchart for the algorithm above looks like this. There are several components to a flowchart. We will use the following convention in CS1010: An arrow indicates the direction of the flow, i.e., what is the next step of the algorithm. A rounded rectangle denotes either the starting (inputs) or ending point (output) of the algorithm. A diamond box represents a \"question\" that can be true or false (yes or no). It indicates a \"branch\" in the flow. Which branch we follow is deteremined the answer to the question in the box. A rectangle represents one or more \"operations\" (such as initialization or manipulation of data) To understand the flowchart above, let's trace through it with the sample input. We will maintain the following table as we trace through the flowchart. At the beginning, just before entering \" \\(i\\) equals \\(k\\) ?\", we have the following: Integers Scanned \\(i\\) \\(l_i\\) \\(k\\) Maximum So Far ( \\(m\\) ) 4 1 1 9 4 Subsequently, we enter a \"loop\", and the values assigned to the symbols at the point after \" \\(i\\) equals \\(k\\) ?\" can be traced as follows: Integers Scanned \\(i\\) \\(l_i\\) \\(k\\) Maximum So Far ( \\(m\\) ) 4 1 1 1 9 4 4 1 -4 2 -4 9 4 4 1 -4 0 3 0 9 4 4 1 -4 0 9 4 9 9 4 4 1 -4 0 9 9 5 9 9 9 4 1 -4 0 9 9 3 6 3 9 9 4 1 -4 0 9 9 3 5 7 5 9 9 4 1 -4 0 9 9 3 5 8 8 8 9 9 4 1 -4 0 9 9 3 5 8 9 `` 9 9 Please spend some time to trace through the flowchart above.","title":"Flowchart"},{"location":"02-algo.html#variables","text":"There are a few important things to take note here. \\(m\\) , \\(i\\) , \\(k\\) , and the list \\(L\\) are what we called states or variables . While in the above, we can think of them as mathematical variables which we can assign values to, in a computer program, a variable is a location in the memory which holds a value. We can perform two very basic operations on the variables: reading and writing. In other words, we can set their values and we can retrieve their values. We can assign the value of one variable to a constant (e.g., set \\(i\\) to 1) or to the value of another variable (e.g., set \\(m\\) to \\(l_i\\) ). In the latter example, we first read the value of \\(l_i\\) , from \\(l_i\\) 's memory location and then we write that value to the memory location of \\(m\\) . Once written, the value of \\(m\\) will not change until the next time we update the value of \\(m\\) . It is important to note that, when \\(i\\) changes, \\(m\\) does not change automatically to the new \\(l_i\\) This behavior is different from that which you may be familiar with in spreadsheet software -- if you set the value of a cell, say A1 to be =B1 , when the value in cell B1 changes, the value A1 also changes automatically. We can also compare the values of two variables. We see two examples above: \" \\(i\\) equals \\(k\\) ?\" \" \\(l_i > m\\) ?\" When we compare, we read the values of the variables from their memory location and checks their relations. We can perform arithmetic operations on the variables: addition, subtraction, etc. We see one example above: \"increment \\(i\\) \". This operation is actually an assignment operation in disguise. We can write it as \"set \\(i\\) to \\(i\\) + 1\". Here, you see that \\(i\\) is referred to twice. This operation reads the value from the memory location of \\(i\\) , adds 1 to it, and then writes the resulting value back to the location of \\(i\\) .","title":"Variables"},{"location":"02-algo.html#bugs","text":"If you follow the execution of the algorithm above, step-by-step, using the example input 4 1 -4 0 9 9 3 5 above, you will obtain the correct maximum value \\(m\\) of 9 . But does that mean that the algorithm is correct? The answer is NO. For an algorithm to correctly solve the given problem, it has to produce the correct result for all valid inputs to the problem. If we can find one counterexample, one input where the algorithm does not produce the correct output, then the algorithm is incorrect. Note that I say does not produce the correct output , which means that either the algorithm produces the wrong output or does not produce any output at all . In this case, we say that the algorithm or the program has a bug . A bug is a defect that causes the algorithm to behave incorrectly. As a software developer, you will spend some time finding bugs in your code, a process known as debugging . A debugger is a tool that helps programmers find bugs in their code. Before we even start the process of debugging, we first have to know if our algorithm is correct. Remember that an algorithm is correct only if it produces the correct output only all possible valid inputs. So, one way to check if an algorithm is correct is to try it with all possible valid inputs. For the problem we are solving above, however, even though the list is finite, there are infinitely many possible inputs, and so, it is impossible to try all possible valid inputs. In practice, we craft a smaller set of test inputs to check if the algorithm behaves correctly for these test inputs, and hope that it is correct for all possible inputs. With experience, you will choose the right set of test inputs to maximize that chances that you will find a bug in your code. There are also systematic ways of deriving test cases so that the test cases cover different paths of execution of the algorithm, but we won't be covering it in CS1010 3 . Another way of checking if an algorithm is correct, is to reason about the behavior of the algorithm. We will do this rather informally in CS1010, starting in 1-2 lectures from now. You get to rigorously prove that an algorithm is correct in a higher level module (CS3230 Design and Analysis of Algorithms). Finally, even if an algorithm is correct, the corresponding program might not be. Recall that an algorithm is a step-by-step process to solve a problem. It is what you want your program to do. You still have to write a program (in C, or other languages) to actually have the computer do what you want it to do (in other words, to implement the algorithm ). This process of translating the algorithm to a computer program, called coding may introduce bugs as well. But we will worry about this later when we learn to program. In the problem set at the end of this lecture, you will see slight variations of the algorithm above. You should check through them to see whether they are correct or not.","title":"Bugs"},{"location":"02-algo.html#problem-set","text":"","title":"Problem Set"},{"location":"02-algo.html#problem-11","text":"The following algorithms are slight variations of the one in the notes above. The differences are highlighted in red. Do they correctly find the maximum integer from a finite list of \\(k\\) integers ( \\(k > 0\\) )? If an algorithm is buggy, give a counter-example where the output is incorrect. In addition, give an example input where the algorithm still produces the correct output, where possible. (a) (b) (c) (d) (e)","title":"Problem 1.1"},{"location":"02-algo.html#problem-12","text":"Change the algorithm above to find the minimum value instead of the maximum value from the given list \\(L = \\langle l_0, ..., l_{k-1}\\rangle\\) . You can also assume that the list \\(L\\) is finite and \\(k > 0\\) for this question.","title":"Problem 1.2"},{"location":"02-algo.html#problem-13","text":"Draw the flowchart for an algorithm, that takes in a list of integers \\(L = \\langle l_0, ..., l_{k-1}\\rangle, k > 0\\) , and compute the sum of all the integers. Think about what variable(s) do you need. The answer is, by the way, always \"Yes.\" \u21a9 Think about why it is important to have a finite number of integers in the input. \u21a9 Software testing is a body of knowledge worthy of an advanced module by itself -- we offer one in CS4218. \u21a9","title":"Problem 1.3"},{"location":"03-func.html","text":"Unit 3: Functions Learning Outcomes: After this unit, students should: understand the concept of a function: (i) function as a high-level abstraction of lower-level operations; (ii) function as a well-defined solution to a sub-problem with zero or more inputs and (possibly) a returned value. be able to see how a problem can be decomposed into sub-problems, each solvable by a function; the functions can then be composed together to solve the original problem; understand the concept of local variables that are internal within a function; be able to apply \"wishful thinking\" in decomposing a problem into sub-problems; apply wishful thinking in solving a problem recursively -- by making a function invokes itself to solve a simpler version of the same problem. Problem: Finding the Range Let's start with another problem. The range of a finite list of at least one integers \\(L\\) is defined as the difference between the maximum and the minimum integers in \\(L\\) . For example, the range for 4 1 -4 0 9 9 3 5 8 is 13 . How do we find the range of a given list? To find the range of a list, we can break the solution down into three subtasks: first, find the maximum, then, find the minimum, and finally, find the difference between the two. From the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)! So, in expressing the algorithm to find the range, we can refer to a previous solution to a sub-problem, which we assume we already know how to solve . Let's call our solution to find the maximum value from a given list \\(L\\) as \\(max\\) . \\(max\\) takes as input (i) a list \\(L\\) and (ii) \\(k\\) , the number of integers in \\(L\\) . It produces, or returns , the maximum value among the integers in \\(L\\) . Borrowing from mathematical notation, we use the notation \\(max(L, k)\\) to represent the maximum value of \\(L\\) . Note that, now, we no longer worry about \\(i\\) and \\(m\\) -- these two variables are now internal, or local , to \\(max(L,k)\\) . Suppose that \\(min(L,k)\\) returns the minimum value among the integers in \\(L\\) , then, the algorithm to find the range of \\(L\\) can be written in a single line: \\[max(L, k) - min(L, k)\\] Functions \\(max\\) and \\(min\\) are examples of a powerful and important concept with many names: function , procedure , subroutine , method , subprogram 1 . In the context of CS1010, we will use the term function . Functions allow us to solve a problem by thinking about the solution at a higher level. We no longer concern with the implementation details. For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far. We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value. Such an assumption, that we already know how to solve a subproblem, is known as wishful thinking . Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later. For instance, consider the following problem: Given a finite list of \\(k\\) integers ( \\(k > 0\\) ), find the mean. The algorithm again can be written in one line: \\[sum(L, k) / k\\] if we assume that we have a function \\(sum\\) that can help us find the total of all \\(k\\) integers. It turns out, in this case, that you should also know how to solve the subproblem \\(sum\\) since it is Problem 1.3 from last week. We can then make this into a function itself, \\(mean(L, k)\\) , which we can now use to solve other more complex problems. Thinking in terms of functions also has another advantage: given a function, we only need to worry about what it does, but not how it is done. In the \\(max(L,k)\\) example above, we do not care if it scans the list \\(L\\) from \\(l_0\\) to \\(l_{k-1}\\) , or from \\(l_{k-1}\\) to \\(l_0\\) . We can treat a function as a black box with well-defined behavior -- given one or more inputs, it will produce a value satisfying certain conditions, i.e., it solves a computational problem. Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems. In CS1010, we will also provide you with some functions to help you with your lab assignments. You will also define your own functions when solving problems with C. In fact, a C program is just a collection of functions calling each other. Note, however, that in C, a function is more general than the description above: a C function may not take in any input, and it may not return any value. Before we continue, let's simplify the functions we have written so far. Let's suppose that we have another function \\(len(L)\\) that takes in a list as an input, and returns the number of items in the list. With this function, we can remove \\(k\\) as one of the inputs to the function \\(max\\) , \\(min\\) , \\(sum\\) and \\(mean\\) . Instead of defining \\(mean(L, k)\\) to be \\(sum(L, k)/k\\) , we can define the function to be \\(mean(L) = sum(L)/len(L)\\) . We can define \\(k\\) to be a local variable within \\(max\\) , \\(min\\) and \\(sum\\) , initialize it before we start computing the respective answers. Problem: Finding Standard Deviation Let's look at another problem: Given \\(L\\) , a finite list of \\(k\\) integers ( \\(k \\ge 1\\) ), find the standard deviation of the integers in \\(L\\) . First, recall that the (population) standard deviation is given by \\[\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\\] where \\(\\mu\\) is the mean of the integers in \\(L\\) . To compute the standard deviation, we first need to compute \\(\\mu\\) , the mean. We already know how to do that: \\(mean(L)\\) . Then, we need to compute \\(\\sum_{i=0}^{k-1} (l_i - \\mu)^2\\) . We can break it down into two subproblems: Given a list \\(L\\) and a constant value \\(x\\) , subtract \\(x\\) from every number in \\(L\\) , giving us a new list. Given a list, square every number in the list, giving us a new list. For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions \\(subtract(L, x)\\) and \\(square(L)\\) , then, the formula \\(\\sum_{i=0}^{k-1} (l_i - \\mu)^2\\) can be computed by the following steps: set \\(\\mu\\) to \\(mean(L)\\) set \\(L'\\) to \\(subtract(L, \\mu)\\) set \\(L''\\) to \\(square(L')\\) set \\(total\\) to \\(sum(L'')\\) . We can also write it in one line: set \\(total\\) to \\(sum(square(subtract(L, mean(L))))\\) Now, to compute the standard deviation, we need to divide \\(total\\) by \\(len(L)\\) and find the square root. But, finding \\(total\\) and dividing the result by \\(len(L)\\) is just \\(mean\\) . To compute square root, we again apply wishful thinking and assume that there is a function \\(sqrt\\) to do so. We can now compute the standard deviation with one line: \\[sqrt(mean(square(subtract(L, mean(L)))))\\] Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems. We also see an example of reuse here -- \\(mean\\) is used twice with different inputs. Returning a list While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant. Let's worry about that later. Now that we have seen how to compute standard deviation by breaking it down the four subproblems, \\(sqrt\\) , \\(mean\\) , \\(square\\) , and \\(subtract\\) , we have to make sure that things we wish can be done can actually be done. The C library, and many programming languages, provide a pre-defined method to compute \\(sqrt\\) . We already know how to compute \\(mean\\) . Computing \\(square\\) can be done as follows: The implementation of \\(subtract\\) is similar. Another Two Solutions for Finding Maximum In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far. Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way. Let's suppose that we have a function \\(max'(L, i, j)\\) , that finds the maximum integer among the elements \\(l_i, l_{i+1}, ... l_j\\) . The function \\(max(L, k)\\) , which finds the maximum among all elements of \\(L\\) , is therefore the same as \\(max'(L, 0, k-1)\\) . Do we know how to solve \\(max'(L, i, j)\\) without checking the integers in \\(L\\) one-by-one? Well, if \\(i\\) equals to \\(j\\) , i.e., there is only one element in the range of \\(l_i, ..., l_j\\) , then yes, the function should simply return the value of \\(l_i\\) . But, what if there are multiple elements in the range? (i.e., \\(i < j\\) )? By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- \\(max'(L, i+1, j)\\) , so the maximum value for the range of \\(l_i, ..., l_j\\) is the larger of the two: either \\(l_i\\) or \\(max'(L, i+1, j)\\) . We can express this algorithm as follows: Let's trace through the algorithm above, using our previous example: 4 1 -4 0 9 9 3 5 8 . Given this list, we compare the first element, 4 , with the maximum of the rest of the list 1 -4 0 9 9 3 5 8 , computed with \\(max'(L, 1,8)\\) . With wishful thinking, we know how to solve \\(max'\\) already -- we get \\(max'(L,1,8)\\) = 9 as the maximum value of 1 -4 0 9 9 3 5 8 . Comparing 4 and 9 , 9 is larger. Thus, the maximum of the whole list is 9 . The solution above involves \\(max'\\) calling itself once to solve the problem. It breaks the problem of finding the maximum in a list of \\(k\\) items into the problem of finding the maximum in a list of \\(k-1\\) items. Now, let's consider a second possibility. What if we break the list into two lists of (roughly) equal length? Let's consider the example 4 1 -4 0 9 9 3 5 . We keep the list to eight items this time so that it is neater example. We can break the list into two smaller lists: 4 1 -4 0 and 9 9 3 5 . By wishful thinking, we know how to find the maximum among 4 1 -4 0 (which is 4 ) and 9 9 3 5 (which is 9 ). What remains is just to pick the larger of the two and we have the maximum of the two lists! Given \\(max'(L, i, j)\\) , if we let \\(n = \\left\\lfloor(i+j)/2\\right\\rfloor\\) , then we can solve \\(max'(L,i,j)\\) by solving two smaller, almost equally sized, sub-problems, \\(max'(L,i,n)\\) and \\(max'(L,n+1,j)\\) . We can express this algorithm as follows: This problem solving technique is called divide-and-conquer . You will see this technique again many times in CS1010, CS2040C, CS3230, and the rest of your computing career. A nice property of this technique is that, if we have more than one processing units, we can ask them to compute \\(max'(L,i,n)\\) and \\(max'(L,n+1,j)\\) in parallel, and thus getting the answer we are looking for, earlier! Example: Finding a Factorial Let us look at another example of a function before we move on to another topic. Suppose we want to write a function \\(factorial(n)\\) for an integer \\(n\\) ( \\(n \\ge 0\\) ) that computes \\(n!\\) . Recall that \\(n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\\) . As a special case, \\(0!\\) is defined to be \\(1\\) . The algorithm to do this can be expressed by the following diagram: Let's look at an example. Let's say we want to compute \\(factorial(4)\\) . We assume we know how to solve this for a smaller problem -- \\(factorial(3)\\) , which is 6. \\(factorial(4)\\) is thus 4 \\(\\times\\) 6, i.e., 24. Recursion: Function Calling Itself \\(max'\\) and \\(factorial\\) are examples of functions that calls itself to solve a simpler version of the problem. This is known as recursion . We will revisit this concept in much greater detail in the later part of CS1010. Problem Set Problem 3.1 : Getting MAD The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is. The absolute deviation is the absolute difference between an element in the list with the mean of values of the list. The mean absolute deviation is the mean of all the absolute difference. In other words, given \\(L = \\{l_0, ... l_{k-1}\\}\\) , the MAD of \\(L\\) is: \\[\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\\] How do you find MAD by composing various functions we have seen? Do you need a new function? Problem 3.2 : Ownself calls ownself (a) Give an algorithm for finding the sum of all the integers in the list \\(L\\) with \\(k\\) ( \\(k > 0\\) ) integers that is recursive. (b) The function \\(pow(i, j)\\) computes \\(i^j\\) . Give an algorithm to compute \\(pow(i, j)\\) recursively. There are subtle differences between these terms -- but they are all a form of functional abstraction , where we abstract out the detailed operations and represent it with a single higher-level \"action\". \u21a9","title":"Unit 3: Functions"},{"location":"03-func.html#unit-3-functions","text":"","title":"Unit 3: Functions"},{"location":"03-func.html#learning-outcomes","text":"After this unit, students should: understand the concept of a function: (i) function as a high-level abstraction of lower-level operations; (ii) function as a well-defined solution to a sub-problem with zero or more inputs and (possibly) a returned value. be able to see how a problem can be decomposed into sub-problems, each solvable by a function; the functions can then be composed together to solve the original problem; understand the concept of local variables that are internal within a function; be able to apply \"wishful thinking\" in decomposing a problem into sub-problems; apply wishful thinking in solving a problem recursively -- by making a function invokes itself to solve a simpler version of the same problem.","title":"Learning Outcomes:"},{"location":"03-func.html#problem-finding-the-range","text":"Let's start with another problem. The range of a finite list of at least one integers \\(L\\) is defined as the difference between the maximum and the minimum integers in \\(L\\) . For example, the range for 4 1 -4 0 9 9 3 5 8 is 13 . How do we find the range of a given list? To find the range of a list, we can break the solution down into three subtasks: first, find the maximum, then, find the minimum, and finally, find the difference between the two. From the previous lecture, you already know how to find the maximum and the minimum (from Problem 1.2)! So, in expressing the algorithm to find the range, we can refer to a previous solution to a sub-problem, which we assume we already know how to solve . Let's call our solution to find the maximum value from a given list \\(L\\) as \\(max\\) . \\(max\\) takes as input (i) a list \\(L\\) and (ii) \\(k\\) , the number of integers in \\(L\\) . It produces, or returns , the maximum value among the integers in \\(L\\) . Borrowing from mathematical notation, we use the notation \\(max(L, k)\\) to represent the maximum value of \\(L\\) . Note that, now, we no longer worry about \\(i\\) and \\(m\\) -- these two variables are now internal, or local , to \\(max(L,k)\\) . Suppose that \\(min(L,k)\\) returns the minimum value among the integers in \\(L\\) , then, the algorithm to find the range of \\(L\\) can be written in a single line: \\[max(L, k) - min(L, k)\\]","title":"Problem: Finding the Range"},{"location":"03-func.html#functions","text":"\\(max\\) and \\(min\\) are examples of a powerful and important concept with many names: function , procedure , subroutine , method , subprogram 1 . In the context of CS1010, we will use the term function . Functions allow us to solve a problem by thinking about the solution at a higher level. We no longer concern with the implementation details. For instance, in the example above, we no longer have to think about checking through the items in the list one-by-one and maintaining the maximum so far, or the minimum so far. We just have to think about how to compute the range, assuming that we already know how to compute the maximum and the minimum value. Such an assumption, that we already know how to solve a subproblem, is known as wishful thinking . Sometimes, it is useful to solve a problem assuming that you know how to solve the subproblem first, then worry about solving the subproblem later. For instance, consider the following problem: Given a finite list of \\(k\\) integers ( \\(k > 0\\) ), find the mean. The algorithm again can be written in one line: \\[sum(L, k) / k\\] if we assume that we have a function \\(sum\\) that can help us find the total of all \\(k\\) integers. It turns out, in this case, that you should also know how to solve the subproblem \\(sum\\) since it is Problem 1.3 from last week. We can then make this into a function itself, \\(mean(L, k)\\) , which we can now use to solve other more complex problems. Thinking in terms of functions also has another advantage: given a function, we only need to worry about what it does, but not how it is done. In the \\(max(L,k)\\) example above, we do not care if it scans the list \\(L\\) from \\(l_0\\) to \\(l_{k-1}\\) , or from \\(l_{k-1}\\) to \\(l_0\\) . We can treat a function as a black box with well-defined behavior -- given one or more inputs, it will produce a value satisfying certain conditions, i.e., it solves a computational problem. Many programming languages, including C which we will be using in CS1010, come with a rich set of predefined functions that we can use to help us solve computational problems. In CS1010, we will also provide you with some functions to help you with your lab assignments. You will also define your own functions when solving problems with C. In fact, a C program is just a collection of functions calling each other. Note, however, that in C, a function is more general than the description above: a C function may not take in any input, and it may not return any value. Before we continue, let's simplify the functions we have written so far. Let's suppose that we have another function \\(len(L)\\) that takes in a list as an input, and returns the number of items in the list. With this function, we can remove \\(k\\) as one of the inputs to the function \\(max\\) , \\(min\\) , \\(sum\\) and \\(mean\\) . Instead of defining \\(mean(L, k)\\) to be \\(sum(L, k)/k\\) , we can define the function to be \\(mean(L) = sum(L)/len(L)\\) . We can define \\(k\\) to be a local variable within \\(max\\) , \\(min\\) and \\(sum\\) , initialize it before we start computing the respective answers.","title":"Functions"},{"location":"03-func.html#problem-finding-standard-deviation","text":"Let's look at another problem: Given \\(L\\) , a finite list of \\(k\\) integers ( \\(k \\ge 1\\) ), find the standard deviation of the integers in \\(L\\) . First, recall that the (population) standard deviation is given by \\[\\sqrt{\\frac{\\sum_{i=0}^{k-1} (l_i - \\mu)^2}{k}}\\] where \\(\\mu\\) is the mean of the integers in \\(L\\) . To compute the standard deviation, we first need to compute \\(\\mu\\) , the mean. We already know how to do that: \\(mean(L)\\) . Then, we need to compute \\(\\sum_{i=0}^{k-1} (l_i - \\mu)^2\\) . We can break it down into two subproblems: Given a list \\(L\\) and a constant value \\(x\\) , subtract \\(x\\) from every number in \\(L\\) , giving us a new list. Given a list, square every number in the list, giving us a new list. For now, let's apply wishful thinking and assume that we know how to compute the above two steps with functions \\(subtract(L, x)\\) and \\(square(L)\\) , then, the formula \\(\\sum_{i=0}^{k-1} (l_i - \\mu)^2\\) can be computed by the following steps: set \\(\\mu\\) to \\(mean(L)\\) set \\(L'\\) to \\(subtract(L, \\mu)\\) set \\(L''\\) to \\(square(L')\\) set \\(total\\) to \\(sum(L'')\\) . We can also write it in one line: set \\(total\\) to \\(sum(square(subtract(L, mean(L))))\\) Now, to compute the standard deviation, we need to divide \\(total\\) by \\(len(L)\\) and find the square root. But, finding \\(total\\) and dividing the result by \\(len(L)\\) is just \\(mean\\) . To compute square root, we again apply wishful thinking and assume that there is a function \\(sqrt\\) to do so. We can now compute the standard deviation with one line: \\[sqrt(mean(square(subtract(L, mean(L)))))\\] Using functions, we can easily pass the output from one function as input to another, essentially chain the functions together, like Lego blocks, to solve problems. We also see an example of reuse here -- \\(mean\\) is used twice with different inputs. Returning a list While the above one-liner is an elegant solution, when we actually implement this in C later, it will not so simple and elegant. Let's worry about that later. Now that we have seen how to compute standard deviation by breaking it down the four subproblems, \\(sqrt\\) , \\(mean\\) , \\(square\\) , and \\(subtract\\) , we have to make sure that things we wish can be done can actually be done. The C library, and many programming languages, provide a pre-defined method to compute \\(sqrt\\) . We already know how to compute \\(mean\\) . Computing \\(square\\) can be done as follows: The implementation of \\(subtract\\) is similar.","title":"Problem: Finding Standard Deviation"},{"location":"03-func.html#another-two-solutions-for-finding-maximum","text":"In the previous lecture, you have seen an algorithm to find the maximum value from a list of integers, which involves checking the elements one-by-one and keeping track of the maximum value so far. Now that we have seen what a function is, we can use the concept of wishful thinking to help us solve this problem in a different way and more elegant way. Let's suppose that we have a function \\(max'(L, i, j)\\) , that finds the maximum integer among the elements \\(l_i, l_{i+1}, ... l_j\\) . The function \\(max(L, k)\\) , which finds the maximum among all elements of \\(L\\) , is therefore the same as \\(max'(L, 0, k-1)\\) . Do we know how to solve \\(max'(L, i, j)\\) without checking the integers in \\(L\\) one-by-one? Well, if \\(i\\) equals to \\(j\\) , i.e., there is only one element in the range of \\(l_i, ..., l_j\\) , then yes, the function should simply return the value of \\(l_i\\) . But, what if there are multiple elements in the range? (i.e., \\(i < j\\) )? By wishful thinking, we assume that we already know how to solve smaller (as in a shorter list) problem -- \\(max'(L, i+1, j)\\) , so the maximum value for the range of \\(l_i, ..., l_j\\) is the larger of the two: either \\(l_i\\) or \\(max'(L, i+1, j)\\) . We can express this algorithm as follows: Let's trace through the algorithm above, using our previous example: 4 1 -4 0 9 9 3 5 8 . Given this list, we compare the first element, 4 , with the maximum of the rest of the list 1 -4 0 9 9 3 5 8 , computed with \\(max'(L, 1,8)\\) . With wishful thinking, we know how to solve \\(max'\\) already -- we get \\(max'(L,1,8)\\) = 9 as the maximum value of 1 -4 0 9 9 3 5 8 . Comparing 4 and 9 , 9 is larger. Thus, the maximum of the whole list is 9 . The solution above involves \\(max'\\) calling itself once to solve the problem. It breaks the problem of finding the maximum in a list of \\(k\\) items into the problem of finding the maximum in a list of \\(k-1\\) items. Now, let's consider a second possibility. What if we break the list into two lists of (roughly) equal length? Let's consider the example 4 1 -4 0 9 9 3 5 . We keep the list to eight items this time so that it is neater example. We can break the list into two smaller lists: 4 1 -4 0 and 9 9 3 5 . By wishful thinking, we know how to find the maximum among 4 1 -4 0 (which is 4 ) and 9 9 3 5 (which is 9 ). What remains is just to pick the larger of the two and we have the maximum of the two lists! Given \\(max'(L, i, j)\\) , if we let \\(n = \\left\\lfloor(i+j)/2\\right\\rfloor\\) , then we can solve \\(max'(L,i,j)\\) by solving two smaller, almost equally sized, sub-problems, \\(max'(L,i,n)\\) and \\(max'(L,n+1,j)\\) . We can express this algorithm as follows: This problem solving technique is called divide-and-conquer . You will see this technique again many times in CS1010, CS2040C, CS3230, and the rest of your computing career. A nice property of this technique is that, if we have more than one processing units, we can ask them to compute \\(max'(L,i,n)\\) and \\(max'(L,n+1,j)\\) in parallel, and thus getting the answer we are looking for, earlier!","title":"Another Two Solutions for Finding Maximum"},{"location":"03-func.html#example-finding-a-factorial","text":"Let us look at another example of a function before we move on to another topic. Suppose we want to write a function \\(factorial(n)\\) for an integer \\(n\\) ( \\(n \\ge 0\\) ) that computes \\(n!\\) . Recall that \\(n! = n \\times n - 1 \\times n - 2 \\times ... 2 \\times 1 = n \\times (n-1)!\\) . As a special case, \\(0!\\) is defined to be \\(1\\) . The algorithm to do this can be expressed by the following diagram: Let's look at an example. Let's say we want to compute \\(factorial(4)\\) . We assume we know how to solve this for a smaller problem -- \\(factorial(3)\\) , which is 6. \\(factorial(4)\\) is thus 4 \\(\\times\\) 6, i.e., 24.","title":"Example: Finding a Factorial"},{"location":"03-func.html#recursion-function-calling-itself","text":"\\(max'\\) and \\(factorial\\) are examples of functions that calls itself to solve a simpler version of the problem. This is known as recursion . We will revisit this concept in much greater detail in the later part of CS1010.","title":"Recursion: Function Calling Itself"},{"location":"03-func.html#problem-set","text":"","title":"Problem Set"},{"location":"03-func.html#problem-31-getting-mad","text":"The mean absolute deviation, or MAD, of a set of integers measures how spread out a set of data is. The absolute deviation is the absolute difference between an element in the list with the mean of values of the list. The mean absolute deviation is the mean of all the absolute difference. In other words, given \\(L = \\{l_0, ... l_{k-1}\\}\\) , the MAD of \\(L\\) is: \\[\\frac{\\sum_{i=0}^{k-1} |l_i - \\mu|}{k}\\] How do you find MAD by composing various functions we have seen? Do you need a new function?","title":"Problem 3.1 : Getting MAD"},{"location":"03-func.html#problem-32-ownself-calls-ownself","text":"(a) Give an algorithm for finding the sum of all the integers in the list \\(L\\) with \\(k\\) ( \\(k > 0\\) ) integers that is recursive. (b) The function \\(pow(i, j)\\) computes \\(i^j\\) . Give an algorithm to compute \\(pow(i, j)\\) recursively. There are subtle differences between these terms -- but they are all a form of functional abstraction , where we abstract out the detailed operations and represent it with a single higher-level \"action\". \u21a9","title":"Problem 3.2 : Ownself calls ownself"},{"location":"04-type.html","text":"Unit 4: Types Learning Outcomes: After this unit, students should: understand the concept of type as a way to interpret the meaning of bits in the memory; be able to calculate the number of different possible values that can be represented by a given number of bits; understand that different types require a different number of bits for representation; be aware that real numbers may not be represented precisely in a computer, and so real numbers should never be used as a type of an integer value; be aware that C is a statically-typed language, in contrast to Python and Javascript, which are dynamically-typed; be aware that the type for all C variables and functions must be declared; be aware that choosing the wrong type could lead to an incorrect implementation of an algorithm. Bits and Bytes Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory. Each unit of either 1 or 0 is known as a bit . 8 bits form a byte . Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits. The bits stored in the memory has no meaning by itself. It has to be interpreted by the machine code. Does a sequence of 1s and 0s represent an integer? A pixel of an image? A sound sample in an audio clip? A month? As a programmer, we have to tag the variable with its type , so that the machine code knows how to interpret the sequence of bits. In addition, the type also tells the machine code, how many bits \"belong\" to this variable. The number of bits of a type is also known as the size of a type. The size of a type determines how many different values a variable of that type can hold. For instance, a type of one bit can only hold two possible values (e.g., 0 or 1 , true or false , black or white ). A type of two bits can hold four values, represented as 00 , 01 , 10 , 11 . In general, a type of \\(k\\) bits can hold \\(2^k\\) values. Integers To represent integers, a type of 8 bits can represent 256 different values. If the type only represents non-negative integers (called unsigned ), then it can hold any value between 0 to 255. If it represents both positive and negative integers (called signed ), it can hold any value between -128 to 127. Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs. With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. This might look big enough for you -- but we can't even fit the results from \\(factorial(21)\\) here! We have to go to 128 bits to represent larger integers. Characters To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters. The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape). The Unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., Emoticons , Braille , Mahjong Tiles ) to be represented. Real Numbers For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits. In CS1231, you will learn that there are uncountably many possible real numbers. But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers. Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer! Because of this, programs that manipulate real numbers leads to weird answers (such as 1.1 + 2.2 becomes 3.3000000000000003 ) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well). Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers . The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos. We do not have a type of size, say, 41 bits. The reason for this has to do with how memory location is addressed. This will again be explained in CS2100. Compound Types In programming, we can represent more complex concepts with compound types , that consists of primitive types such as integers, real numbers, and characters. A sentence, for instance, can be represented as a sequence of characters (called string ). A point, for instance, can be represent a pair of real numbers \\((x,y)\\) . Type Declaration In C, which we will use in CS1010, we have to associate every variable with a type, and once a variable is declared with a type, the type cannot be changed. This behavior is known as static typing. Some programming languages, such as Javascript and Python, are dynamically typed. The type of a variable may change depending on the value the variable is assigned to. When we write a function, we have to declare the types of each of the parameters and the return value as well. Take the function \\(mean(L, k)\\) as an example. We have said that \\(L\\) is a list 1 of integers. So each element in \\(L\\) should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage). What about \\(k\\) ? \\(k\\) refers to the number of elements in \\(L\\) , so it has to be an integer. As for the value returned by \\(mean(L, k)\\) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number. So we should choose a type that represents a real number for the return value. Importance of Type Choosing the wrong type to represent a variable can lead to buggy code. Suppose we say that \\(mean(L, k)\\) returns an integer, then when we call \\(mean\\) on the input 1 2 3 4 , we will get 2 as the answer, instead of 2.5 as it should. We have not talked about how to represent a list yet. I will do that in a later unit. \u21a9","title":"Unit 4: Types"},{"location":"04-type.html#unit-4-types","text":"","title":"Unit 4: Types"},{"location":"04-type.html#learning-outcomes","text":"After this unit, students should: understand the concept of type as a way to interpret the meaning of bits in the memory; be able to calculate the number of different possible values that can be represented by a given number of bits; understand that different types require a different number of bits for representation; be aware that real numbers may not be represented precisely in a computer, and so real numbers should never be used as a type of an integer value; be aware that C is a statically-typed language, in contrast to Python and Javascript, which are dynamically-typed; be aware that the type for all C variables and functions must be declared; be aware that choosing the wrong type could lead to an incorrect implementation of an algorithm.","title":"Learning Outcomes:"},{"location":"04-type.html#bits-and-bytes","text":"Recall from Unit 1 that machine code and data manipulated by machine code are all stored as a sequence of 1s and 0s in the memory. Each unit of either 1 or 0 is known as a bit . 8 bits form a byte . Remember from Unit 2 that a variable is a memory location that stores a value, as a sequence of bits. The bits stored in the memory has no meaning by itself. It has to be interpreted by the machine code. Does a sequence of 1s and 0s represent an integer? A pixel of an image? A sound sample in an audio clip? A month? As a programmer, we have to tag the variable with its type , so that the machine code knows how to interpret the sequence of bits. In addition, the type also tells the machine code, how many bits \"belong\" to this variable. The number of bits of a type is also known as the size of a type. The size of a type determines how many different values a variable of that type can hold. For instance, a type of one bit can only hold two possible values (e.g., 0 or 1 , true or false , black or white ). A type of two bits can hold four values, represented as 00 , 01 , 10 , 11 . In general, a type of \\(k\\) bits can hold \\(2^k\\) values.","title":"Bits and Bytes"},{"location":"04-type.html#integers","text":"To represent integers, a type of 8 bits can represent 256 different values. If the type only represents non-negative integers (called unsigned ), then it can hold any value between 0 to 255. If it represents both positive and negative integers (called signed ), it can hold any value between -128 to 127. Depending on the needs (how much memory we have, how big is the number we need to represent), programmers have to decide on the size of the type used for a variable in their programs. With 64 bits, a signed integer can store any value between -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807. This might look big enough for you -- but we can't even fit the results from \\(factorial(21)\\) here! We have to go to 128 bits to represent larger integers.","title":"Integers"},{"location":"04-type.html#characters","text":"To represent a character (i.e., a symbol representing a letter, number, punctuation, etc), we use 8 bits for English characters. The ASCII standard maps 127 binary sequences to common characters you can type on your keyboard (including 0-9, A-Z, a-z, all sorts of punctuations: <>?:\"{}!@#$%^&*()_+-=[]\\';/., and special characters like return and escape). The Unicode standard uses up to 32 bits per character, allowing many non-English letter characters (e.g., Emoticons , Braille , Mahjong Tiles ) to be represented.","title":"Characters"},{"location":"04-type.html#real-numbers","text":"For real numbers, because we need to represent a huge number of possible values, we normally use 32 bits or 64 bits. In CS1231, you will learn that there are uncountably many possible real numbers. But, no matter how many bits we use, we can only represent a finite number of possible values for real numbers. Here, we run into a limit of digitizing information into 0s and 1s -- we can never represent all possible real numbers in a computer! Because of this, programs that manipulate real numbers leads to weird answers (such as 1.1 + 2.2 becomes 3.3000000000000003 ) and so, we have to take special care when dealing with real numbers when writing programs (not just in C, but in many other languages as well). Hence, if we only expect a variable to hold an integer, we should not choose a type that represents real numbers . The details of how a sequence of bits can represent integers and real numbers (both positive and negative numbers) are covered in CS2100. You should have also noticed that in the discussion above, we talk about types that are 8, 16, 32, 64, 128 bits -- all power of twos. We do not have a type of size, say, 41 bits. The reason for this has to do with how memory location is addressed. This will again be explained in CS2100.","title":"Real Numbers"},{"location":"04-type.html#compound-types","text":"In programming, we can represent more complex concepts with compound types , that consists of primitive types such as integers, real numbers, and characters. A sentence, for instance, can be represented as a sequence of characters (called string ). A point, for instance, can be represent a pair of real numbers \\((x,y)\\) .","title":"Compound Types"},{"location":"04-type.html#type-declaration","text":"In C, which we will use in CS1010, we have to associate every variable with a type, and once a variable is declared with a type, the type cannot be changed. This behavior is known as static typing. Some programming languages, such as Javascript and Python, are dynamically typed. The type of a variable may change depending on the value the variable is assigned to. When we write a function, we have to declare the types of each of the parameters and the return value as well. Take the function \\(mean(L, k)\\) as an example. We have said that \\(L\\) is a list 1 of integers. So each element in \\(L\\) should have an integer type (how many bits to use will depend on the range of numbers we want the program to possibly handle and how frugal we are about memory usage). What about \\(k\\) ? \\(k\\) refers to the number of elements in \\(L\\) , so it has to be an integer. As for the value returned by \\(mean(L, k)\\) , even when the inputs are all integers (and thus, the sum is an integer), the mean value can be a real number. So we should choose a type that represents a real number for the return value. Importance of Type Choosing the wrong type to represent a variable can lead to buggy code. Suppose we say that \\(mean(L, k)\\) returns an integer, then when we call \\(mean\\) on the input 1 2 3 4 , we will get 2 as the answer, instead of 2.5 as it should. We have not talked about how to represent a list yet. I will do that in a later unit. \u21a9","title":"Type Declaration"},{"location":"1819s1.html","text":"CS1010 from AY2018/19 Semester 1 Here are some information and materials from the offering of CS1010 in AY 2018/19 Semester 1. Student Feedback Midterm Final (Questions only) Final (w Answers) PE 1 PE 2 Lecture Slides Screencast 1 2 3 4 5 6 7 8 9 10 11 12 Note: Screencasts are password protected.","title":"18/19 Semester 1"},{"location":"1819s1.html#cs1010-from-ay201819-semester-1","text":"Here are some information and materials from the offering of CS1010 in AY 2018/19 Semester 1.","title":"CS1010 from AY2018/19 Semester 1"},{"location":"1819s1.html#student-feedback","text":"","title":"Student Feedback"},{"location":"1819s1.html#midterm","text":"","title":"Midterm"},{"location":"1819s1.html#final-questions-only","text":"","title":"Final (Questions only)"},{"location":"1819s1.html#final-w-answers","text":"","title":"Final (w Answers)"},{"location":"1819s1.html#pe-1","text":"","title":"PE 1"},{"location":"1819s1.html#pe-2","text":"Lecture Slides Screencast 1 2 3 4 5 6 7 8 9 10 11 12 Note: Screencasts are password protected.","title":"PE 2"},{"location":"about.html","text":"About CS1010 Module Description This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students. Who/Where/When Instructor : Ooi Wei Tsang Lecture Venue : Online ( Zoom link ) Lecture Time : Every Monday, 12noon - 2pm Q&A Hour via Zoom : Wei Tsang: Every Tuesday, 4pm - 5pm, at AS6 #05-14 or ( Zoom link ) Important Dates Midterm Assessment : Monday, 27 September, 2021 (12noon - 2pm) Practical Exam 1 : Saturday, 2 October, 2021 (9am - 12noon) Practical Exam 2 : Saturday, 6 November, 2021 (9am - 12noon) Final Assessment : Tuesday, 25 November, 2021 (5pm - 7pm) All assessments below are conducted online. Assessment Weightage Programming Assignments : 30% Final Assessment : 25% Midterm Assessment : 10% Practical Exam 1 : 10% Practical Exam 2 : 15% Online Quizzes : 10%","title":"About CS1010"},{"location":"about.html#about-cs1010","text":"","title":"About CS1010"},{"location":"about.html#module-description","text":"This module introduces the fundamental concepts of problem solving by computing and programming using an imperative programming language. It is the first and foremost introductory course to computing. It is also the first part of a three-part series on introductory programming and problem solving by computing, which also includes CS2030 and CS2040. Topics covered include problem solving by computing, writing pseudo-codes, basic problem formulation and problem solving, program development, coding, testing and debugging, fundamental programming constructs (variables, types, expressions, assignments, functions, control structures, etc.), fundamental data structures: arrays, strings and structures, simple file processing, and basic recursion. This module is appropriate for SoC students.","title":"Module Description"},{"location":"about.html#whowherewhen","text":"Instructor : Ooi Wei Tsang Lecture Venue : Online ( Zoom link ) Lecture Time : Every Monday, 12noon - 2pm Q&A Hour via Zoom : Wei Tsang: Every Tuesday, 4pm - 5pm, at AS6 #05-14 or ( Zoom link )","title":"Who/Where/When"},{"location":"about.html#important-dates","text":"Midterm Assessment : Monday, 27 September, 2021 (12noon - 2pm) Practical Exam 1 : Saturday, 2 October, 2021 (9am - 12noon) Practical Exam 2 : Saturday, 6 November, 2021 (9am - 12noon) Final Assessment : Tuesday, 25 November, 2021 (5pm - 7pm) All assessments below are conducted online.","title":"Important Dates"},{"location":"about.html#assessment-weightage","text":"Programming Assignments : 30% Final Assessment : 25% Midterm Assessment : 10% Practical Exam 1 : 10% Practical Exam 2 : 15% Online Quizzes : 10%","title":"Assessment Weightage"},{"location":"accounts.html","text":"CS1010 Accounts We will be using a variety of services for CS1010. To take CS1010, please make sure you have the following accounts: SoC UNIX Account You can get one here: https://mysoc.nus.edu.sg/~newacct/ This account allows you to access SoC UNIX resources, including the main computing host running Solaris, sunfire , and computer clusters running Ubuntu / CentOS. We will be using the compute clusters for CS1010. Make sure that \"General Unix Servers\" and \"The SoC Compute Cluster\" are enabled in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi GitHub Account CS1010 uses GitHub Classroom for programming assignment submissions and grading. You should register for a GitHub account if you do not have one. This account will likely stay with you for the rest of your computing career. So choose your username wisely. Piazza Account CS1010 uses Piazza for Q&A and discussion. You should have received an email to register for Piazza.","title":"Accounts"},{"location":"accounts.html#cs1010-accounts","text":"We will be using a variety of services for CS1010. To take CS1010, please make sure you have the following accounts:","title":"CS1010 Accounts"},{"location":"accounts.html#soc-unix-account","text":"You can get one here: https://mysoc.nus.edu.sg/~newacct/ This account allows you to access SoC UNIX resources, including the main computing host running Solaris, sunfire , and computer clusters running Ubuntu / CentOS. We will be using the compute clusters for CS1010. Make sure that \"General Unix Servers\" and \"The SoC Compute Cluster\" are enabled in MySoC here: https://mysoc.nus.edu.sg/~myacct/services.cgi","title":"SoC UNIX Account"},{"location":"accounts.html#github-account","text":"CS1010 uses GitHub Classroom for programming assignment submissions and grading. You should register for a GitHub account if you do not have one. This account will likely stay with you for the rest of your computing career. So choose your username wisely.","title":"GitHub Account"},{"location":"accounts.html#piazza-account","text":"CS1010 uses Piazza for Q&A and discussion. You should have received an email to register for Piazza.","title":"Piazza Account"},{"location":"archive.html","text":"Older Announcements Assignment 4 is out Thu Oct 1 12:26:51 +08 2020 In view of the upcoming PE1, the next assignment has an extended deadline (two more days, until Thursday 23:59) and reduced workload (only two questions). But I am posting it early in case you are looking for problems to solve to practice for PE1. Please do pay attention to the additional requirements and grading criteria outlined. Here it is: Assignment 4 . Guide to Documenting Your Code Thu Oct 1 12:24:04 +08 2020 We have posted a new guide to documenting your code . This is a good practice that we have been holding off enforcing until now so that you can focus on the logic and correctness of your code. After PE1, you are expected to write proper documentation in your code, starting with Assignment 4. Exercise 3 is out Tue Sep 29 17:39:38 +08 2020 Here is ungraded Exercise 3 . Assignment 3 is out Thu Sep 17 10:09:37 +08 2020 Here is your Assignment 3 on one dimensional arrays. Note that this is due on the Tuesday after the recess week. But do work on it early since the week after the recess week is the midterm + PE week. Even though arrays are not covered in the midterm + PE, you can use these assignments to strengten your understanding and confidence in using loops and recursion to solve problems. Practice PE Exercise Released Tue Sep 15 18:54:23 +08 2020 You can use the PE question from 18/19 Semester 1 as the practice paper. Download the question paper Accept the assignment on GitHub Run ~cs1010/get-pe18 on any PE host to get the skeleton code and test cases Run ~cs1010/submit-pe18 to submit/archive your solution on GitHub Post-Lecture 6 Materials Mon Sep 14 18:04:12 +08 2020 Folks, here is your post-lecture materials for Lecture 6: lecture video , slides , and the diagnostic quiz . Notes for Lecture 6 Sat Sep 12 14:50:07 +08 2020 We will cover Units 13 - 16 in our last lecture before the break. Check under Notes on the left menu for the notes. Assignment 2 Released Thu Sep 10 11:39:40 +08 2020 Here is your Assignment 2 on loops. Exercise 2 Released Tue Sep 8 11:30:27 +08 2020 Here is your ungraded Exercise 2 on loops. This is for you to practice before Assignment 2 is released on Thursday. Post-Lecture 5 Materials Sat Sep 5 19:35:57 +08 2020 Folks, here is your weekly dose of lecture video , slides , and the diagnostic quiz . Notes for Lecture 5; Details about PE and Midterm Sat Sep 5 19:35:57 +08 2020 We will cover Unit 11 and Unit 12 in Lecture 5. We will also go through some important details about the upcoming midterm and PE1 . Assignment 1 Release Thu Sep 3 10:28:04 +08 2020 Here is your first graded programming assignment . Due next Tuesday (Sep 8) 23:59 SGT. Ungraded Exercise 1 Available Tue Sep 1 21:51:56 +08 2020 If you would like to have more practices before Assignment 1, here is Exercise 1 , an ungraded exercise on conditionals and logical expression. Post-Lecture Materials for Lecture 4 Available Mon Aug 31 18:33:02 +08 2020 Please enjoy the video , slides , and the diagnostic quiz for Lecture 4 today. The older announcements below are moved to the old announcements sections in the left bar. Notes for Lecture 4 Available Sat Aug 29 10:15:34 +08 2020 We will cover Unit 8 , Unit 9 , and Unit 10 in Lecture 4. The notes have been posted. Catch Up Session Fri Aug 28 11:57:46 +08 2020 The Piazza Q&A Page for tomorrow's catch-up session is now open and will remain open for the next 24 hours. Please post your questions and vote for questions that you would like us to answer live tomorrow. The link to Zoom can be found at the usual place . Bonus Quiz: Using the CS1010 PE We added a bonus diagnostic quiz on using the CS1010 PE for you to self-diagnose your basic understanding of the usage of the CS1010 PE nodes. This quiz is due next Thursday 10am as usual. This quiz carries the same weight as the rest of the quizzes. Recall that we will take the best 10 out of all the quizzes in CS1010 to compute your marks. Exercise 0 Posted Fri Aug 28 05:12:47 +08 2020 In case you missed the lab yesterday, here is Exercise 0 , a warm-up to get your ready to write some C code and prepare for the coming assignments. Exercise 0 is not graded but it is important that you complete it before Assignment 1, which is going to be released next week. Slides, Video, and Quiz for Lecture 3 Mon Aug 24 17:24:46 +08 2020 Here you go: Slides , Video Quiz Notes for Lecture 3 and for Using C in CS1010 Fri Aug 21 16:18:17 +08 2020 We will cover Unit 5 , Unit 6 , and Unit 7 in Lecture 3. The notes have been posted. We have also posted notes on using C in CS1010: C in CS1010 lists and explains the features of C that are banned or discouraged in this module; CS1010 I/O library documents the APIs provided by the libcs1010 library, something that we provide to shield the pain and danger of using printf and scanf from you; C Style documents the programming style that we should all follow in CS1010. Compiler Messages lists the common warnings and errors that students encounter in CS1010. This list will be updated throughout the semester. Slides, Video, Quiz for Lecture 2 Mon Aug 17 14:59:16 +08 2020 The slides , video , and post-lecture quiz for Lecture 2 are now available. Notes for Lecture 2 Posted Fri Aug 14 21:54:24 +08 2020 We will cover Unit 3 and Unit 4 in Lecture 2. The notes have been posted. Lecture 1 Mon Aug 10 14:17:40 +08 2020 Lecture 1 has been recorded and posted. You can watch it here . Please read through the notes and watch the lecture. After that, you can try the post-lecture diagnostic quiz to test your own understanding. The slides are posted as well. Notes for Lecture 1 Posted Sun Aug 9 07:20:35 +08 2020 We will cover Unit 1 and Unit 2 in our very first lecture. You can always check out the notes under the menu items notes.","title":"Older Announcements"},{"location":"archive.html#older-announcements","text":"Assignment 4 is out Thu Oct 1 12:26:51 +08 2020 In view of the upcoming PE1, the next assignment has an extended deadline (two more days, until Thursday 23:59) and reduced workload (only two questions). But I am posting it early in case you are looking for problems to solve to practice for PE1. Please do pay attention to the additional requirements and grading criteria outlined. Here it is: Assignment 4 . Guide to Documenting Your Code Thu Oct 1 12:24:04 +08 2020 We have posted a new guide to documenting your code . This is a good practice that we have been holding off enforcing until now so that you can focus on the logic and correctness of your code. After PE1, you are expected to write proper documentation in your code, starting with Assignment 4. Exercise 3 is out Tue Sep 29 17:39:38 +08 2020 Here is ungraded Exercise 3 . Assignment 3 is out Thu Sep 17 10:09:37 +08 2020 Here is your Assignment 3 on one dimensional arrays. Note that this is due on the Tuesday after the recess week. But do work on it early since the week after the recess week is the midterm + PE week. Even though arrays are not covered in the midterm + PE, you can use these assignments to strengten your understanding and confidence in using loops and recursion to solve problems. Practice PE Exercise Released Tue Sep 15 18:54:23 +08 2020 You can use the PE question from 18/19 Semester 1 as the practice paper. Download the question paper Accept the assignment on GitHub Run ~cs1010/get-pe18 on any PE host to get the skeleton code and test cases Run ~cs1010/submit-pe18 to submit/archive your solution on GitHub Post-Lecture 6 Materials Mon Sep 14 18:04:12 +08 2020 Folks, here is your post-lecture materials for Lecture 6: lecture video , slides , and the diagnostic quiz . Notes for Lecture 6 Sat Sep 12 14:50:07 +08 2020 We will cover Units 13 - 16 in our last lecture before the break. Check under Notes on the left menu for the notes. Assignment 2 Released Thu Sep 10 11:39:40 +08 2020 Here is your Assignment 2 on loops. Exercise 2 Released Tue Sep 8 11:30:27 +08 2020 Here is your ungraded Exercise 2 on loops. This is for you to practice before Assignment 2 is released on Thursday. Post-Lecture 5 Materials Sat Sep 5 19:35:57 +08 2020 Folks, here is your weekly dose of lecture video , slides , and the diagnostic quiz . Notes for Lecture 5; Details about PE and Midterm Sat Sep 5 19:35:57 +08 2020 We will cover Unit 11 and Unit 12 in Lecture 5. We will also go through some important details about the upcoming midterm and PE1 . Assignment 1 Release Thu Sep 3 10:28:04 +08 2020 Here is your first graded programming assignment . Due next Tuesday (Sep 8) 23:59 SGT. Ungraded Exercise 1 Available Tue Sep 1 21:51:56 +08 2020 If you would like to have more practices before Assignment 1, here is Exercise 1 , an ungraded exercise on conditionals and logical expression. Post-Lecture Materials for Lecture 4 Available Mon Aug 31 18:33:02 +08 2020 Please enjoy the video , slides , and the diagnostic quiz for Lecture 4 today. The older announcements below are moved to the old announcements sections in the left bar. Notes for Lecture 4 Available Sat Aug 29 10:15:34 +08 2020 We will cover Unit 8 , Unit 9 , and Unit 10 in Lecture 4. The notes have been posted. Catch Up Session Fri Aug 28 11:57:46 +08 2020 The Piazza Q&A Page for tomorrow's catch-up session is now open and will remain open for the next 24 hours. Please post your questions and vote for questions that you would like us to answer live tomorrow. The link to Zoom can be found at the usual place . Bonus Quiz: Using the CS1010 PE We added a bonus diagnostic quiz on using the CS1010 PE for you to self-diagnose your basic understanding of the usage of the CS1010 PE nodes. This quiz is due next Thursday 10am as usual. This quiz carries the same weight as the rest of the quizzes. Recall that we will take the best 10 out of all the quizzes in CS1010 to compute your marks. Exercise 0 Posted Fri Aug 28 05:12:47 +08 2020 In case you missed the lab yesterday, here is Exercise 0 , a warm-up to get your ready to write some C code and prepare for the coming assignments. Exercise 0 is not graded but it is important that you complete it before Assignment 1, which is going to be released next week. Slides, Video, and Quiz for Lecture 3 Mon Aug 24 17:24:46 +08 2020 Here you go: Slides , Video Quiz Notes for Lecture 3 and for Using C in CS1010 Fri Aug 21 16:18:17 +08 2020 We will cover Unit 5 , Unit 6 , and Unit 7 in Lecture 3. The notes have been posted. We have also posted notes on using C in CS1010: C in CS1010 lists and explains the features of C that are banned or discouraged in this module; CS1010 I/O library documents the APIs provided by the libcs1010 library, something that we provide to shield the pain and danger of using printf and scanf from you; C Style documents the programming style that we should all follow in CS1010. Compiler Messages lists the common warnings and errors that students encounter in CS1010. This list will be updated throughout the semester. Slides, Video, Quiz for Lecture 2 Mon Aug 17 14:59:16 +08 2020 The slides , video , and post-lecture quiz for Lecture 2 are now available. Notes for Lecture 2 Posted Fri Aug 14 21:54:24 +08 2020 We will cover Unit 3 and Unit 4 in Lecture 2. The notes have been posted. Lecture 1 Mon Aug 10 14:17:40 +08 2020 Lecture 1 has been recorded and posted. You can watch it here . Please read through the notes and watch the lecture. After that, you can try the post-lecture diagnostic quiz to test your own understanding. The slides are posted as well. Notes for Lecture 1 Posted Sun Aug 9 07:20:35 +08 2020 We will cover Unit 1 and Unit 2 in our very first lecture. You can always check out the notes under the menu items notes.","title":"Older Announcements"},{"location":"assignment.html","text":"Guide to Programming Assignments Timeline There will be weekly take-home programming assignments, each consisting of 1 to 4 questions. These programming assignments collectively contribute to 30% of your final grade. The programming assignment is released on the CS1010 website every Thursday, with a deadline given. You must submit all questions for each particular programming assignment before the deadline. General Advice You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly. Remember to spend some time thinking about the algorithm for each question. Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program. Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. You should test your program thoroughly with your own test data before submission. Please note that: You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work. Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire. Late Submission All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.) For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%. For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty). Method of Submission Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted. Identifying Yourself In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Gamora (Group 10) Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted. Grading Only the final submission of each assignment will be graded. For each assignment, we will provide you will a limited set of test data. During grading, we may grade your program with additional test data. Each programming assignment will be graded differently. Generally, marks are given for attempt, correctness, design, and style, and documentation. The weight of each one will be adjusted over the semester. A program that cannot compile (i.e., there is a compilation error) will receive 0 marks for correctness. In addition, there is an additional -1 mark for each warning that your program received. Always make sure that your program compiles cleanly without any warning. Feedback will be provided by the tutors on GitHub. Use of Piazza If you have doubts about the problem statements of an assignment, you may raise them on Piazza. But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum. Please exercise discretion when posting to Piazza. Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site). Disallowed Syntax Some programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged. We also discourage the use of certain syntax for this module, (e.g., ++ ) you should not use them. The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification. You can find the list of banned and discouraged C features in the article \" C in CS1010 .\" Plagiarism You are NOT to copy from others or allow others to copy your programs. We take plagiarism seriously. See our policies page for details. This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others. This guideline is adapted from Aaron Tan's CS1010 guideline.","title":"Overview"},{"location":"assignment.html#guide-to-programming-assignments","text":"","title":"Guide to Programming Assignments"},{"location":"assignment.html#timeline","text":"There will be weekly take-home programming assignments, each consisting of 1 to 4 questions. These programming assignments collectively contribute to 30% of your final grade. The programming assignment is released on the CS1010 website every Thursday, with a deadline given. You must submit all questions for each particular programming assignment before the deadline.","title":"Timeline"},{"location":"assignment.html#general-advice","text":"You are advised to (i) spend some time thinking before you begin coding, (ii) practice incremental coding and (iii) test your programs thoroughly. Remember to spend some time thinking about the algorithm for each question. Write out the pseudo-code or draw out the flowchart on your own before you start typing in your program. Incremental coding means do NOT type in the whole long program in a single session and then compile it. Instead, type your program in bits and pieces and compile it incrementally. Try to maintain a compilable program even while you are working on it. Submitting a compilable program that partially works is better than submitting an un-compilable one; this is especially important for your practical exams. You should test your program thoroughly with your own test data before submission. Please note that: You may assume that all input data are correct unless otherwise stated. Hence you do NOT need to do input data validation. This is to allow you to focus on getting the program right, instead of worrying about making your program fool-proof which involves a lot more work. Copying others' programs or relying on others to help you with these assignments will only offer a short-term reprieve. When Practical Exam (PE) time comes, your inadequacy will be exposed and the consequence would be dire.","title":"General Advice"},{"location":"assignment.html#late-submission","text":"All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not.) For late submission, there is a 1% penalty (of the total awarded marks for that particular assignment) for every 5-minute after the deadline, capped at 80%. For example, if an assignment is awarded 40 marks, and it is submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as it has hit the cap of 80% penalty).","title":"Late Submission"},{"location":"assignment.html#method-of-submission","text":"Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted.","title":"Method of Submission"},{"location":"assignment.html#identifying-yourself","text":"In every C file that you submit to CS1010, you need to identify yourself by writing your name and tutorial group. Marks will be deducted if you fail to do so. You need to edit the line: 1 @author XXXX (Group YYYY) and change it to something like: 1 @author Gamora (Group 10) Please follow the instructions provided in each programming assignment to submit the programs to GitHub. Programs submitted through other means, such as emails, will NOT be accepted.","title":"Identifying Yourself"},{"location":"assignment.html#grading","text":"Only the final submission of each assignment will be graded. For each assignment, we will provide you will a limited set of test data. During grading, we may grade your program with additional test data. Each programming assignment will be graded differently. Generally, marks are given for attempt, correctness, design, and style, and documentation. The weight of each one will be adjusted over the semester. A program that cannot compile (i.e., there is a compilation error) will receive 0 marks for correctness. In addition, there is an additional -1 mark for each warning that your program received. Always make sure that your program compiles cleanly without any warning. Feedback will be provided by the tutors on GitHub.","title":"Grading"},{"location":"assignment.html#use-of-piazza","text":"If you have doubts about the problem statements of an assignment, you may raise them on Piazza. But before that, please read through the problem statements carefully first, and check if the same questions have been asked and answered on the forum. Please exercise discretion when posting to Piazza. Before the deadline, you are NOT to post the solution to the assignment, complete or partial, on Piazza (or any publicly accessible online site).","title":"Use of Piazza"},{"location":"assignment.html#disallowed-syntax","text":"Some programming assignments may explicitly disallow the use of certain syntax. Generally, using syntax or statements which are not yet covered either in class or in the assignment statement is strongly discouraged. We also discourage the use of certain syntax for this module, (e.g., ++ ) you should not use them. The assignments are designed such that you should not need to do so (even though doing so may result in your program being shorter or more efficient). If the objective of the assignment is undermined, the penalty for using such forbidden syntax will be heavy. If in doubt, please ask for clarification. You can find the list of banned and discouraged C features in the article \" C in CS1010 .\"","title":"Disallowed Syntax"},{"location":"assignment.html#plagiarism","text":"You are NOT to copy from others or allow others to copy your programs. We take plagiarism seriously. See our policies page for details. This means that you should also guard your solution carefully, not posting them to publicly accessible places, or change the permissions of the files on the CS1010 PE hosts so that it is accessible by others. This guideline is adapted from Aaron Tan's CS1010 guideline.","title":"Plagiarism"},{"location":"c-in-cs1010.html","text":"C in CS1010 C is a simple and flexible language, providing programmers with many different ways to achieve the same thing. Some of these features that C provides, however, could be bug-prone. Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students. He feels that some of these features from C are not useful for beginners (or even seasoned programmers). Furthermore, some features in C simply encourages bad programming habits that are widely frowned upon. Some would lead to insecure programs. As such, in CS1010, we ban and discourage the use of certain operators, functions, constructs, and features in C. This article summarizes this list. This is a work in progress article. As we learn more about C, we will amend this list. Banned in CS1010 The banned items should not be used in CS1010. Students should use alternatives. The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used. 1. The ++ and -- operators. Why? These operators lead to potential undefined behavior. E.g., i = i++; The potential confusion is caused by the difference between i++ and ++i . What should be used instead? Use i += 1 or i -= 1 instead of i++ or i-- 2. Skipping of curly braces for single statement conditional or loop body Why? Could lead to dangling else confusion Easy to forget to put back the {} pair if the body is modified beyond a single statements What should be used instead? Always use {} even if the conditional or loop body contains only a single statement. 3. Nested conditional operator ?: Why? Can get difficult to read, understand, and modify. Example: 1 a = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z); What should be used Use nested if-else loop 4. Global variables Why? It makes the code hard to reason about and trace, as you have no idea who will modify these variables. For instance, if x is not a global variable, we can safely assert that x is still 1 after calling f() . If x is a global variable, we can no longer assert anything about x . 1 2 3 x = 1 ; f (); // { x == 1 } What should be used instead Declare the variables as local, automatic variables, and pass them around. 5. The type int and short Why? C standard guarantees that both short and int are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767. This is too small for many purposes. We are not concerned about memory usage in CS1010. If we do want to have precise control over memory, we should be anyway using the types from stdint.h . What should be used instead long , which is guaranteed to be at least 32 bits. Exception If a function from C library calls for the use of int and offers no long alternative, then we have to use int . 6. The type float Why? Not enough precision and will cause floating-point errors. What should be used instead double Exception If a function from C library calls for the use of float and offers no double alternative, then we have to use float . 7. Using integer values for true / false Why? Confusing and error-prone What should be used instead Use the bool type, and the values true and false . 8. goto Why? makes the logical flow of the code hard to follow and trace What should be used instead combinations of conditionals and loops Discouraged in CS1010 These are things that are not strictly banned, but their usage is discouraged. Students should use them only if they know very well what they are doing. Use at own perils. 1. printf and scanf Functions Why? Using the wrong format modifier for printf could lead to strange results Using the wrong format modifier for scanf could lead to memory corruption Need to look up what is the right format modifier to use Need to preallocate memory for scanf of strings scanf is not secure scanf is not a pure function. Prefers students to learn about the concept of pure functions first. etc. etc. What should be used instead The CS1010 I/O library 2. switch Statements Why? Bug prone (missing break would cause the case to fall through) Only works on ordinal types. What should be used instead if - else statements 3. break and continue Statements Why? Using break and continue complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone. What should be used instead Simple loops with a single entry and a single exit point. Use flag variables to indicate special conditions to exit or continue with the loop. 4. Skipping parenthesis Why? Parenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations. We should add parenthesis to make sure the intention of the code is clear. Why should be used instead Parenthesis","title":"C in CS1010"},{"location":"c-in-cs1010.html#c-in-cs1010","text":"C is a simple and flexible language, providing programmers with many different ways to achieve the same thing. Some of these features that C provides, however, could be bug-prone. Wei Tsang has written enough buggy programs himself and seen enough buggy programs from students. He feels that some of these features from C are not useful for beginners (or even seasoned programmers). Furthermore, some features in C simply encourages bad programming habits that are widely frowned upon. Some would lead to insecure programs. As such, in CS1010, we ban and discourage the use of certain operators, functions, constructs, and features in C. This article summarizes this list. This is a work in progress article. As we learn more about C, we will amend this list.","title":"C in CS1010"},{"location":"c-in-cs1010.html#banned-in-cs1010","text":"The banned items should not be used in CS1010. Students should use alternatives. The teaching staff reserves the right to apply a penalty while grading the assignments and practical exams if these banned features are used.","title":"Banned in CS1010"},{"location":"c-in-cs1010.html#1-the-and-operators","text":"","title":"1. The ++ and -- operators."},{"location":"c-in-cs1010.html#why","text":"These operators lead to potential undefined behavior. E.g., i = i++; The potential confusion is caused by the difference between i++ and ++i .","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead","text":"Use i += 1 or i -= 1 instead of i++ or i--","title":"What should be used instead?"},{"location":"c-in-cs1010.html#2-skipping-of-curly-braces-for-single-statement-conditional-or-loop-body","text":"","title":"2. Skipping of curly braces for single statement conditional or loop body"},{"location":"c-in-cs1010.html#why_1","text":"Could lead to dangling else confusion Easy to forget to put back the {} pair if the body is modified beyond a single statements","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_1","text":"Always use {} even if the conditional or loop body contains only a single statement.","title":"What should be used instead?"},{"location":"c-in-cs1010.html#3-nested-conditional-operator","text":"","title":"3. Nested conditional operator ?:"},{"location":"c-in-cs1010.html#why_2","text":"Can get difficult to read, understand, and modify. Example: 1 a = (x > y) ? ((y > z) ? y : z) : ((x > z) ? x : z);","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used","text":"Use nested if-else loop","title":"What should be used"},{"location":"c-in-cs1010.html#4-global-variables","text":"","title":"4. Global variables"},{"location":"c-in-cs1010.html#why_3","text":"It makes the code hard to reason about and trace, as you have no idea who will modify these variables. For instance, if x is not a global variable, we can safely assert that x is still 1 after calling f() . If x is a global variable, we can no longer assert anything about x . 1 2 3 x = 1 ; f (); // { x == 1 }","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_2","text":"Declare the variables as local, automatic variables, and pass them around.","title":"What should be used instead"},{"location":"c-in-cs1010.html#5-the-type-int-and-short","text":"","title":"5. The type int and short"},{"location":"c-in-cs1010.html#why_4","text":"C standard guarantees that both short and int are at least 16 bits, which limits its guaranteed range to only -32,768 to 32,767. This is too small for many purposes. We are not concerned about memory usage in CS1010. If we do want to have precise control over memory, we should be anyway using the types from stdint.h .","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_3","text":"long , which is guaranteed to be at least 32 bits.","title":"What should be used instead"},{"location":"c-in-cs1010.html#exception","text":"If a function from C library calls for the use of int and offers no long alternative, then we have to use int .","title":"Exception"},{"location":"c-in-cs1010.html#6-the-type-float","text":"","title":"6. The type float"},{"location":"c-in-cs1010.html#why_5","text":"Not enough precision and will cause floating-point errors.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_4","text":"double","title":"What should be used instead"},{"location":"c-in-cs1010.html#exception_1","text":"If a function from C library calls for the use of float and offers no double alternative, then we have to use float .","title":"Exception"},{"location":"c-in-cs1010.html#7-using-integer-values-for-true-false","text":"","title":"7. Using integer values for true / false"},{"location":"c-in-cs1010.html#why_6","text":"Confusing and error-prone","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_5","text":"Use the bool type, and the values true and false .","title":"What should be used instead"},{"location":"c-in-cs1010.html#8-goto","text":"","title":"8. goto"},{"location":"c-in-cs1010.html#why_7","text":"makes the logical flow of the code hard to follow and trace","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_6","text":"combinations of conditionals and loops","title":"What should be used instead"},{"location":"c-in-cs1010.html#discouraged-in-cs1010","text":"These are things that are not strictly banned, but their usage is discouraged. Students should use them only if they know very well what they are doing. Use at own perils.","title":"Discouraged in CS1010"},{"location":"c-in-cs1010.html#1-printf-and-scanf-functions","text":"","title":"1. printf and scanf Functions"},{"location":"c-in-cs1010.html#why_8","text":"Using the wrong format modifier for printf could lead to strange results Using the wrong format modifier for scanf could lead to memory corruption Need to look up what is the right format modifier to use Need to preallocate memory for scanf of strings scanf is not secure scanf is not a pure function. Prefers students to learn about the concept of pure functions first. etc. etc.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_7","text":"The CS1010 I/O library","title":"What should be used instead"},{"location":"c-in-cs1010.html#2-switch-statements","text":"","title":"2. switch Statements"},{"location":"c-in-cs1010.html#why_9","text":"Bug prone (missing break would cause the case to fall through) Only works on ordinal types.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_8","text":"if - else statements","title":"What should be used instead"},{"location":"c-in-cs1010.html#3-break-and-continue-statements","text":"","title":"3. break and continue Statements"},{"location":"c-in-cs1010.html#why_10","text":"Using break and continue complicates the flow of a loop, marks it harder to reason about the correctness of the loop, and is, therefore, bug-prone.","title":"Why?"},{"location":"c-in-cs1010.html#what-should-be-used-instead_9","text":"Simple loops with a single entry and a single exit point. Use flag variables to indicate special conditions to exit or continue with the loop.","title":"What should be used instead"},{"location":"c-in-cs1010.html#4-skipping-parenthesis","text":"","title":"4. Skipping parenthesis"},{"location":"c-in-cs1010.html#why_11","text":"Parenthesis makes it clear to the reader the order of evaluation of arithmetic operations / logical operations. We should add parenthesis to make sure the intention of the code is clear.","title":"Why?"},{"location":"c-in-cs1010.html#why-should-be-used-instead","text":"Parenthesis","title":"Why should be used instead"},{"location":"clang.html","text":"CS1010 Compilation Guide 1. Compile a standalone C program Suppose we have a standalone C program teh.c that does not use any external libraries. We can compile the program using the command 1 ooiwt@pe118:~$ clang teh.c This command should create an executable called a.out in the current directory, which you can then run with: 1 ooiwt@pe118:~$ ./a.out If you are looking for a test teh.c to try this out, there is one at ~cs1010/teh.c , which you can copy over. 2. Renaming executable file The name a.out is an abbreviation for assembler output , a name that many compilers kept as the default output name since the 60s. We should, however, give our executable more descriptive name, by using the -o flag. ( o is the mnemonic for output). 1 ooiwt@pe118:~$ clang teh.c -o teh or 1 ooiwt@pe118:~$ clang -o teh teh.c The command above would create an executable called teh . Beware of the order If you are not careful and run the following command instead: 1 ooiwt@pe118:~$ clang -o teh.c teh clang would overwrite your code teh.c -- all your hard work will be gone!! 3. Warning for possible bugs. The clang checks for syntax errors in your C files -- i.e., things that violate the C syntax rules. The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules. You can ask clang to warn you about this, using the -W flag ( W is the mnemonic for warning -- note the capital W). The manual for clang lists different types of warnings that clang can warn you about. For instance, we can ask clang to warn us by enabling -Wall warnings. The command to do so is: 1 ooiwt@pe118:~$ clang -Wall teh.c -o teh For beginners, it is highly recommended that you always compile with at least -Wall , -Wextra , and the -Wpedantic flag. clang warning flags -Wall in clang does not catually enable all warnings. -Weverything enables every warning but it could be overwhelming for beginners. In CS1010 assignments, we will provide a Makefile so that you can use make to automate the compilation process. Appropriate warning flags will be enabled for you. 4. Generating additional information for debugging. In order to use the debugger lldb to trace through and debug your program, clang needs to generate additional information and store them in the executable file. We can instruct clang to generate them with the flag -g ( g for generate). 1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh It is recommended that you always compile with -g flags during the development phase. If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the -g flag and compile with the optimization flags (e.g., -O ) instead. 5. Linking with the standard library. To link with a standard library, we use the -l flag to specify the name of the library to link. For instance, to link with the C standard math library (abbreviated as m ), you issue the command: 1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm 6. Linking with 3rd party library By default, clang looks for headers and libraries in the systems directories ( /usr/include , /usr/lib , etc) and the current working directory. If you use a third-party library, you usually need to tell clang where to look for the corresponding headers and libraries. You can use the -I flag and the -L flag for these purposes. For instance, if you have a library installed under your home called citadel , and the file citadel.h can be found under ~/citadel/include and the file libcitadel.a can be found under ~/citadel/lib , to tell clang where to find these files, you can compile with: 1 ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel For instance, to link with the CS1010 I/O library on the PE nodes, you can run 1 ooiwt@pe118:~$ clang -Wall -g -I ~cs1010/include -L ~cs1010/lib teh.c -lcs1010","title":"CLang"},{"location":"clang.html#cs1010-compilation-guide","text":"","title":"CS1010 Compilation Guide"},{"location":"clang.html#1-compile-a-standalone-c-program","text":"Suppose we have a standalone C program teh.c that does not use any external libraries. We can compile the program using the command 1 ooiwt@pe118:~$ clang teh.c This command should create an executable called a.out in the current directory, which you can then run with: 1 ooiwt@pe118:~$ ./a.out If you are looking for a test teh.c to try this out, there is one at ~cs1010/teh.c , which you can copy over.","title":"1. Compile a standalone C program"},{"location":"clang.html#2-renaming-executable-file","text":"The name a.out is an abbreviation for assembler output , a name that many compilers kept as the default output name since the 60s. We should, however, give our executable more descriptive name, by using the -o flag. ( o is the mnemonic for output). 1 ooiwt@pe118:~$ clang teh.c -o teh or 1 ooiwt@pe118:~$ clang -o teh teh.c The command above would create an executable called teh . Beware of the order If you are not careful and run the following command instead: 1 ooiwt@pe118:~$ clang -o teh.c teh clang would overwrite your code teh.c -- all your hard work will be gone!!","title":"2. Renaming executable file"},{"location":"clang.html#3-warning-for-possible-bugs","text":"The clang checks for syntax errors in your C files -- i.e., things that violate the C syntax rules. The compiler, however, is smart enough to identify possible bugs -- errors that will cause your program to behave incorrectly, even if the syntax follows C's rules. You can ask clang to warn you about this, using the -W flag ( W is the mnemonic for warning -- note the capital W). The manual for clang lists different types of warnings that clang can warn you about. For instance, we can ask clang to warn us by enabling -Wall warnings. The command to do so is: 1 ooiwt@pe118:~$ clang -Wall teh.c -o teh For beginners, it is highly recommended that you always compile with at least -Wall , -Wextra , and the -Wpedantic flag. clang warning flags -Wall in clang does not catually enable all warnings. -Weverything enables every warning but it could be overwhelming for beginners. In CS1010 assignments, we will provide a Makefile so that you can use make to automate the compilation process. Appropriate warning flags will be enabled for you.","title":"3. Warning for possible bugs."},{"location":"clang.html#4-generating-additional-information-for-debugging","text":"In order to use the debugger lldb to trace through and debug your program, clang needs to generate additional information and store them in the executable file. We can instruct clang to generate them with the flag -g ( g for generate). 1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh It is recommended that you always compile with -g flags during the development phase. If you need to measure the performance (e.g., how fast it runs) of your program or when you are releasing the program to the public, you can remove the -g flag and compile with the optimization flags (e.g., -O ) instead.","title":"4. Generating additional information for debugging."},{"location":"clang.html#5-linking-with-the-standard-library","text":"To link with a standard library, we use the -l flag to specify the name of the library to link. For instance, to link with the C standard math library (abbreviated as m ), you issue the command: 1 ooiwt@pe118:~$ clang -Wall -g teh.c -o teh -lm","title":"5. Linking with the standard library."},{"location":"clang.html#6-linking-with-3rd-party-library","text":"By default, clang looks for headers and libraries in the systems directories ( /usr/include , /usr/lib , etc) and the current working directory. If you use a third-party library, you usually need to tell clang where to look for the corresponding headers and libraries. You can use the -I flag and the -L flag for these purposes. For instance, if you have a library installed under your home called citadel , and the file citadel.h can be found under ~/citadel/include and the file libcitadel.a can be found under ~/citadel/lib , to tell clang where to find these files, you can compile with: 1 ooiwt@pe118:~$ clang -Wall -g -I ~/citadel/include -L ~/citadel/lib teh.c -o teh -lm -lcitadel For instance, to link with the CS1010 I/O library on the PE nodes, you can run 1 ooiwt@pe118:~$ clang -Wall -g -I ~cs1010/include -L ~cs1010/lib teh.c -lcs1010","title":"6. Linking with 3rd party library"},{"location":"environments.html","text":"The CS1010 Programming Environment C is a common programming language and you can find different implementations of C compiler on many platforms. Wikipedia lists more than 40 different C compilers . These different compilers support different processor architecture, operating systems, may behave slightly differently, and may support different features of C standards. It is therefore important for CS1010 to stick to a single platform and single compiler. Our platform of choice is Ubuntu 18.04 (or later) using the clang compiler ( version 6.0 or later ). The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ... , pe120 . ( pe stands for \"programming environment\"). We will refer to these servers generally as the PE hosts. pe115 and pe116 For this semester, the two servers pe115 and pe116 are not available. You can choose which of the 8 hosts to use. You share the same home directory across all the hosts (this home directory, however, is different from that of stu ). For simplicity, the following guide uses pe111 in all examples. Do keep in mind that you can use other hosts for CS1010 to spread out the load. While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using servers similar to the PE hosts. It is therefore advisable for you to familiarize yourself with accessing the PE servers via ssh and edit your program with either vim . Basic Requirements You need to have an SoC UNIX account. If you do not have one, you can apply for one online . Once you have an account, you need to activate your access to the PE hosts , which is part of the SoC computer clusters. You need an ssh client. macOS and Linux users should already have it installed by default. Windows 10 users should install the Windows Subsystem for Linux and use Linux. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command lines instructions below do not apply. The Command to SSH Run: 1 ssh <username>@pe111.comp.nus.edu.sg Replace <username> with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@pe111.comp.nus.edu.sg After the command above, following the instructions on the screen. The first time you ever connect to pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your SoC UNIX password. Accessing The PE Hosts from Outside SoC The PE hosts can only be accessed from within the School of Computing networks. If you want to access it from outside, you need to connect through SoC VPN. First, you need to set up a Virtual Private Network (VPN) (See instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network. Windows 10 Users: FortiClient from Windows Store Students have reported that running FortiClient downloaded from the Windows Store does not allow one to ssh from WSL to SoC hosts as expected. Therefore, for Windows 10 users, please download and install FortiClient VPN directly from FortiClient's website . Setting up SSH Keys Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication. You can use 1 ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on PE pe111 . On pe111 , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on PE are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote machine are set to 600 . Once set up, you need not enter your password every time you run ssh or scp . Stability of Network Connection Note that a stable network connection is required to use the PE hosts for a long period of time without interruption. If you encounter frequent disconnections while working at home or on campus while connected wirelessly, please make sure that your WiFi signal is strong and there is no interference from other sources. Troubleshooting Suppose you try to connect to pe111 using: 1 ssh pe111.comp.nus.edu.sg and you get the following error: ssh: Could not resolve hostname pe111.comp.nus.edu.sg ssh cannot recognize the name pe111 , it is likely that you are not connected to the SoC VPN. Connection closed by 192.168.48.xxx port 22 You have connected to the PE host, but you are kicked out because you have no permission to use the host. Make sure you have activated your access to \"SoC computer clusters\" here: https://mysoc.nus.edu.sg/~myacct/services.cgi Permission denied, please try again You did not enter the correct password or username. Please use the username and password of your SoC UNIX account which you have created here: https://mysoc.nus.edu.sg/~newacct/ . Check that you have entered your username correctly. It is case sensitive . If you have lost your password, go here: https://mysoc.nus.edu.sg/~myacct/iforgot.cgi Could not chdir to home directory /home/o/ooiwt: Permission denied This error means that you have successfully connect to the PE hosts, but you have no access to your own home directory. This should not happen. Please send an email with the above error message to helpdesk@comp.nus.edu.sg , include the PE hosts that you connected to with this error and your username. The system administrator can reset the permission of your home directory for you.","title":"Programming Environments"},{"location":"environments.html#the-cs1010-programming-environment","text":"C is a common programming language and you can find different implementations of C compiler on many platforms. Wikipedia lists more than 40 different C compilers . These different compilers support different processor architecture, operating systems, may behave slightly differently, and may support different features of C standards. It is therefore important for CS1010 to stick to a single platform and single compiler. Our platform of choice is Ubuntu 18.04 (or later) using the clang compiler ( version 6.0 or later ). The school has provided a list of computing servers for you to use. You can access them remotely via ssh , or secure shell. The hosts are named pe111 , pe112 , ... , pe120 . ( pe stands for \"programming environment\"). We will refer to these servers generally as the PE hosts. pe115 and pe116 For this semester, the two servers pe115 and pe116 are not available. You can choose which of the 8 hosts to use. You share the same home directory across all the hosts (this home directory, however, is different from that of stu ). For simplicity, the following guide uses pe111 in all examples. Do keep in mind that you can use other hosts for CS1010 to spread out the load. While it is possible for you to complete the programming assignments on your own computers, the practical exams are done in a controlled environment using servers similar to the PE hosts. It is therefore advisable for you to familiarize yourself with accessing the PE servers via ssh and edit your program with either vim .","title":"The CS1010 Programming Environment"},{"location":"environments.html#basic-requirements","text":"You need to have an SoC UNIX account. If you do not have one, you can apply for one online . Once you have an account, you need to activate your access to the PE hosts , which is part of the SoC computer clusters. You need an ssh client. macOS and Linux users should already have it installed by default. Windows 10 users should install the Windows Subsystem for Linux and use Linux. For older versions of Windows, such as those used in the SoC's programming labs, you can check out XShell 6 (free for home/school use), or PuTTY . These are GUI-based programs so the command lines instructions below do not apply.","title":"Basic Requirements"},{"location":"environments.html#the-command-to-ssh","text":"Run: 1 ssh <username>@pe111.comp.nus.edu.sg Replace <username> with your SoC UNIX username, for instance, I would do: 1 ssh ooiwt@pe111.comp.nus.edu.sg After the command above, following the instructions on the screen. The first time you ever connect to pe111.comp.nus.edu.sg , you will be warned that you are connecting to a previously unknown host. Say yes , and you will be prompted with your SoC UNIX password.","title":"The Command to SSH"},{"location":"environments.html#accessing-the-pe-hosts-from-outside-soc","text":"The PE hosts can only be accessed from within the School of Computing networks. If you want to access it from outside, you need to connect through SoC VPN. First, you need to set up a Virtual Private Network (VPN) (See instruction here ). The staff at helpdesk@comp.nus.edu.sg or the IT helpdesk in COM1, Level 1, will be able to help with you setting up if needed. SoC VPN vs NUS VPN Note that SoC VPN is different from NUS VPN. Connecting to NUS VPN only allows you access to the NUS internal network, but not the SoC internal network. Windows 10 Users: FortiClient from Windows Store Students have reported that running FortiClient downloaded from the Windows Store does not allow one to ssh from WSL to SoC hosts as expected. Therefore, for Windows 10 users, please download and install FortiClient VPN directly from FortiClient's website .","title":"Accessing The PE Hosts from Outside SoC"},{"location":"environments.html#setting-up-ssh-keys","text":"Once you are comfortable with UNIX, you can set up a pair of public/private keys for authentication. You can use 1 ssh-keygen -t rsa to generate a pair of keys on your local computer. Keep the private key id_rsa on your local machine in the hidden ~/.ssh directory, and copy the public key id_rsa.pub to your home directory on PE pe111 . On pe111 , run 1 cat id_rsa.pub >> ~/.ssh/authorized_keys Make sure that the permission for .ssh both on the local machine and on PE are set to 700 and the files id_rsa on the local machine and authorized_keys on the remote machine are set to 600 . Once set up, you need not enter your password every time you run ssh or scp .","title":"Setting up SSH Keys"},{"location":"environments.html#stability-of-network-connection","text":"Note that a stable network connection is required to use the PE hosts for a long period of time without interruption. If you encounter frequent disconnections while working at home or on campus while connected wirelessly, please make sure that your WiFi signal is strong and there is no interference from other sources.","title":"Stability of Network Connection"},{"location":"environments.html#troubleshooting","text":"Suppose you try to connect to pe111 using: 1 ssh pe111.comp.nus.edu.sg and you get the following error: ssh: Could not resolve hostname pe111.comp.nus.edu.sg ssh cannot recognize the name pe111 , it is likely that you are not connected to the SoC VPN. Connection closed by 192.168.48.xxx port 22 You have connected to the PE host, but you are kicked out because you have no permission to use the host. Make sure you have activated your access to \"SoC computer clusters\" here: https://mysoc.nus.edu.sg/~myacct/services.cgi Permission denied, please try again You did not enter the correct password or username. Please use the username and password of your SoC UNIX account which you have created here: https://mysoc.nus.edu.sg/~newacct/ . Check that you have entered your username correctly. It is case sensitive . If you have lost your password, go here: https://mysoc.nus.edu.sg/~myacct/iforgot.cgi Could not chdir to home directory /home/o/ooiwt: Permission denied This error means that you have successfully connect to the PE hosts, but you have no access to your own home directory. This should not happen. Please send an email with the above error message to helpdesk@comp.nus.edu.sg , include the PE hosts that you connected to with this error and your username. The system administrator can reset the permission of your home directory for you.","title":"Troubleshooting"},{"location":"final.html","text":"Final Assessment Important Information Date: 24 November 2020 (Tuesday) Time: 5pm to 7 pm Venue: Online Scope: Units 1-29, Assignments 1-9, Tutorials 1-11 Format: MCQs and Short Structured Questions Duration: 120 minutes Open Book (You can refer to printed/written notes but no online references are allowed) A calculator is allowed (although you do not need it) E-Exam Procedure We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010. 2.1 Exam Taking Software We will use Luminus Quiz for the final test. 2.2 Proctoring Protocol Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The browser running Luminuz Quiz running on your PC must be in full-screen mode. No other tabs are allowed on the browser. 2.4. Seeking Clarifications on Exam Questions You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\". 2.5. Multi-part Exam CS1010 final assessment is a single-part examination with no break in between. Screen Capturing Screen-capture software - similar to Midterm / PE1 / PE2, you will be required to upload your video to LumiNUS by November 24, 2200 hrs Submission link: https://luminus.nus.edu.sg/modules/c7b362a0-6aee-4b22-b4da-f9e8074249fd/files/84adf298-21a1-4c57-9cf6-4d58c8a0edd5 Secondary device to run Zoom Meeting for invigilation - this should be powered and running for the entire duration of the assessment Do note that failure to comply with proctoring requirements may result in a mark of 0 for the Final and/or other disciplinary action Zoom Session Assignment See Piazza for Zoom links and Luminus for grouping. Invigilators and Email Address See Piazza","title":"Final Assessment"},{"location":"final.html#final-assessment","text":"","title":"Final Assessment"},{"location":"final.html#important-information","text":"Date: 24 November 2020 (Tuesday) Time: 5pm to 7 pm Venue: Online Scope: Units 1-29, Assignments 1-9, Tutorials 1-11 Format: MCQs and Short Structured Questions Duration: 120 minutes Open Book (You can refer to printed/written notes but no online references are allowed) A calculator is allowed (although you do not need it)","title":"Important Information"},{"location":"final.html#e-exam-procedure","text":"We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010.","title":"E-Exam Procedure"},{"location":"final.html#21-exam-taking-software","text":"We will use Luminus Quiz for the final test.","title":"2.1 Exam Taking Software"},{"location":"final.html#22-proctoring-protocol","text":"Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The browser running Luminuz Quiz running on your PC must be in full-screen mode. No other tabs are allowed on the browser.","title":"2.2 Proctoring Protocol"},{"location":"final.html#24-seeking-clarifications-on-exam-questions","text":"You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\".","title":"2.4. Seeking Clarifications on Exam Questions"},{"location":"final.html#25-multi-part-exam","text":"CS1010 final assessment is a single-part examination with no break in between.","title":"2.5. Multi-part Exam"},{"location":"final.html#screen-capturing","text":"Screen-capture software - similar to Midterm / PE1 / PE2, you will be required to upload your video to LumiNUS by November 24, 2200 hrs Submission link: https://luminus.nus.edu.sg/modules/c7b362a0-6aee-4b22-b4da-f9e8074249fd/files/84adf298-21a1-4c57-9cf6-4d58c8a0edd5 Secondary device to run Zoom Meeting for invigilation - this should be powered and running for the entire duration of the assessment Do note that failure to comply with proctoring requirements may result in a mark of 0 for the Final and/or other disciplinary action","title":"Screen Capturing"},{"location":"final.html#zoom-session-assignment","text":"See Piazza for Zoom links and Luminus for grouping.","title":"Zoom Session Assignment"},{"location":"final.html#invigilators-and-email-address","text":"See Piazza","title":"Invigilators and Email Address"},{"location":"library.html","text":"The CS1010 I/O Library To help students get started with C programming without worrying too much about the details and pitfalls of using printf and scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings. The libraries are pre-installed in CS1010 programming environments , with cs1010.h located under ~cs1010/include and libcs1010.a located under ~cs1010/lib . Using the Library Header To use the CS1010 I/O library, you should #include the file cs1010.h , like this: 1 #include \"cs1010.h\" at the top of your C program. Linking The CS1010 I/O library is provided as the file libcs1010.a . To link to the library, you need to compile with -lcs1010 . Usually, you need to specify where you can find cs1010.h with the -I flag, and libcs1010.a with the -L flag. On the CS1010 programming environment, you would need to compile using the command line: 1 clang -I ~cs1010/include -L ~cs1010/lib hello.c -lcs1010 Although it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again. For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program. We have also automated this for you for your assignments and exercises using the make command. Reading of a Single Value The CS1010 library supports reading of long value, double value, and strings (both space-separated words and newline-separated lines) from the standard input. For long and double . The relevant methods are: long cs1010_read_long() Returns a long value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid long value -- in which case the value LONG_MAX will be returned. Example: 1 long year = cs1010_read_long (); double cs1010_read_double() Returns a double value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid double value -- in which case the value DBL_MAX will be returned. Example: 1 double cap = cs1010_read_double (); char* cs1010_read_word() Returns a char * pointing to the next white-space-separated string from the standard input. A white-space character is defined based on the standard C function isspace() and includes the space , tab \\t , and newline \\n character. Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 char * word = cs1010_read_word (); // use word to do something : : free ( word ); char* cs1010_read_line() Returns a char * pointing to the next new-line-separated string from the standard input. The string returns from cs1010_read_line() includes the newline character (if one is found). Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 char * line = cs1010_read_line (); // use line to do something : : free ( line ); Reading of Multiple Values The CS1010 library also supports reading of multiple values. long* cs1010_read_long_array(long k) Returns k numbers of long values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid long value -- in which case the value LONG_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 6 7 long * values = cs1010_read_long_array ( 10 ); if ( values != NULL ) { // Do something with array values : : free ( values ); } double* cs1010_read_double_array(long k) Returns k numbers of double values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid double value -- in which case the value DBL_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 6 7 double * values = cs1010_read_double_array ( 10 ); if ( values != NULL ) { // Do something with array values : : free ( values ); } char** cs1010_read_word_array(long k) Returns k white-space-separated words read from the standard input stored in an array. The notion of \"word\" is the same to cs1010_read_word() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling free . 1 2 3 4 5 6 7 8 9 10 char ** words = cs1010_read_word_array ( 10 ); if ( words != NULL ) { // Do something with array words : : for ( long i = 0 ; i < 10 ; i += 1 ) { free ( words [ i ]); } free ( words ); } char** cs1010_read_line_array(long k) Returns k new-line-separated words read from the standard input stored in an array. The notion of line is the same to cs1010_read_line() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling free . 1 2 3 4 5 6 7 8 9 10 char ** lines = cs1010_read_line_array ( 10 ); if ( lines != NULL ) { // Do something with array lines : : for ( long i = 0 ; i < 10 ; i += 1 ) { free ( lines [ i ]); } free ( lines ); } Printing of a Single Value The CS1010 library provides a few convenience functions to format and print long and double values to the standard output. void cs1010_print_long(long value) and void cs1010_println_long(long value) Print value to the standard output (with printf format %ld ). The cs1010_println_long version prints a newline after the value. 1 2 3 long x ; : cs1010_print_long ( x ); void cs1010_print_double(double value) and void cs1010_println_double(double value) Print value to the standard output (with printf format %.4f ). The cs1010_println_double version prints a newline after the value. 1 2 3 double x ; : cs1010_println_double ( x ); void cs1010_print_string(char *str) and void cs1010_println_string(char *str) Print a given string str to the standard output. These functions are provided for completeness and is a simple wrapper around printf(str) and printf(\"%s\\n\", str) repsectively. 1 cs1010_println_string ( \"hello world!\" ); Printing single character There is no cs1010_print_char method. You can use putchar from the C standard library for this purpose. Clearing screen The CS1010 library provides a function to clear your screen. 1 cs1010_clear_screen (); Installing the Library If you want to install the libraries on your own computer for purposes other than CS1010, you can do the following: To get an updated copy of the library, clone it from its git repo on GitHub with the command: 1 git clone https://github.com/nus-cs1010/libcs1010.git It is recommended you do this in your home directory. You should see an output similar to: 1 2 3 4 5 Cloning into 'libcs1010'... remote: Counting objects: 6, done. remote: Compressing objects: 100% (3/3), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. After that, you should see a subdirectory libcs1010 created in your current directory. Inside, there should be a file called Makefile , and two subdirectories called include and src . To compile the library, run 1 make This should compile the file src/cs1010.c and create a static C library named libcs1010.a under the lib directory.","title":"CS1010 I/O Library"},{"location":"library.html#the-cs1010-io-library","text":"To help students get started with C programming without worrying too much about the details and pitfalls of using printf and scanf , we provide a simple-to-use library to read and write integers, floating point numbers, and strings. The libraries are pre-installed in CS1010 programming environments , with cs1010.h located under ~cs1010/include and libcs1010.a located under ~cs1010/lib .","title":"The CS1010 I/O Library"},{"location":"library.html#using-the-library","text":"","title":"Using the Library"},{"location":"library.html#header","text":"To use the CS1010 I/O library, you should #include the file cs1010.h , like this: 1 #include \"cs1010.h\" at the top of your C program.","title":"Header"},{"location":"library.html#linking","text":"The CS1010 I/O library is provided as the file libcs1010.a . To link to the library, you need to compile with -lcs1010 . Usually, you need to specify where you can find cs1010.h with the -I flag, and libcs1010.a with the -L flag. On the CS1010 programming environment, you would need to compile using the command line: 1 clang -I ~cs1010/include -L ~cs1010/lib hello.c -lcs1010 Although it is a long string to type, you should type it once and use up arrow in bash to go back to this command over-and-over again. For advanced students, we suggest that you put this in a shell script so that you just need to run the shell script to compile the program. We have also automated this for you for your assignments and exercises using the make command.","title":"Linking"},{"location":"library.html#reading-of-a-single-value","text":"The CS1010 library supports reading of long value, double value, and strings (both space-separated words and newline-separated lines) from the standard input. For long and double . The relevant methods are: long cs1010_read_long() Returns a long value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid long value -- in which case the value LONG_MAX will be returned. Example: 1 long year = cs1010_read_long (); double cs1010_read_double() Returns a double value from the standard input. An error message will be printed (to stderr ) if the input sequence is not a valid double value -- in which case the value DBL_MAX will be returned. Example: 1 double cap = cs1010_read_double (); char* cs1010_read_word() Returns a char * pointing to the next white-space-separated string from the standard input. A white-space character is defined based on the standard C function isspace() and includes the space , tab \\t , and newline \\n character. Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 char * word = cs1010_read_word (); // use word to do something : : free ( word ); char* cs1010_read_line() Returns a char * pointing to the next new-line-separated string from the standard input. The string returns from cs1010_read_line() includes the newline character (if one is found). Returns NULL if there is an error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 char * line = cs1010_read_line (); // use line to do something : : free ( line );","title":"Reading of a Single Value"},{"location":"library.html#reading-of-multiple-values","text":"The CS1010 library also supports reading of multiple values. long* cs1010_read_long_array(long k) Returns k numbers of long values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid long value -- in which case the value LONG_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 6 7 long * values = cs1010_read_long_array ( 10 ); if ( values != NULL ) { // Do something with array values : : free ( values ); } double* cs1010_read_double_array(long k) Returns k numbers of double values read from the standard input stored in an array. An error message will be printed (to stderr ) for each input that is not a valid double value -- in which case the value DBL_MAX will be populated in the corresponding array element. Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated by calling free . 1 2 3 4 5 6 7 double * values = cs1010_read_double_array ( 10 ); if ( values != NULL ) { // Do something with array values : : free ( values ); } char** cs1010_read_word_array(long k) Returns k white-space-separated words read from the standard input stored in an array. The notion of \"word\" is the same to cs1010_read_word() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each word and for the whole array by calling free . 1 2 3 4 5 6 7 8 9 10 char ** words = cs1010_read_word_array ( 10 ); if ( words != NULL ) { // Do something with array words : : for ( long i = 0 ; i < 10 ; i += 1 ) { free ( words [ i ]); } free ( words ); } char** cs1010_read_line_array(long k) Returns k new-line-separated words read from the standard input stored in an array. The notion of line is the same to cs1010_read_line() . Returns NULL if there is a memory allocation error. If the returned value is non-NULL, the caller is responsible for freeing the memory allocated for each line and for the whole array by calling free . 1 2 3 4 5 6 7 8 9 10 char ** lines = cs1010_read_line_array ( 10 ); if ( lines != NULL ) { // Do something with array lines : : for ( long i = 0 ; i < 10 ; i += 1 ) { free ( lines [ i ]); } free ( lines ); }","title":"Reading of Multiple Values"},{"location":"library.html#printing-of-a-single-value","text":"The CS1010 library provides a few convenience functions to format and print long and double values to the standard output. void cs1010_print_long(long value) and void cs1010_println_long(long value) Print value to the standard output (with printf format %ld ). The cs1010_println_long version prints a newline after the value. 1 2 3 long x ; : cs1010_print_long ( x ); void cs1010_print_double(double value) and void cs1010_println_double(double value) Print value to the standard output (with printf format %.4f ). The cs1010_println_double version prints a newline after the value. 1 2 3 double x ; : cs1010_println_double ( x ); void cs1010_print_string(char *str) and void cs1010_println_string(char *str) Print a given string str to the standard output. These functions are provided for completeness and is a simple wrapper around printf(str) and printf(\"%s\\n\", str) repsectively. 1 cs1010_println_string ( \"hello world!\" ); Printing single character There is no cs1010_print_char method. You can use putchar from the C standard library for this purpose.","title":"Printing of a Single Value"},{"location":"library.html#clearing-screen","text":"The CS1010 library provides a function to clear your screen. 1 cs1010_clear_screen ();","title":"Clearing screen"},{"location":"library.html#installing-the-library","text":"If you want to install the libraries on your own computer for purposes other than CS1010, you can do the following: To get an updated copy of the library, clone it from its git repo on GitHub with the command: 1 git clone https://github.com/nus-cs1010/libcs1010.git It is recommended you do this in your home directory. You should see an output similar to: 1 2 3 4 5 Cloning into 'libcs1010'... remote: Counting objects: 6, done. remote: Compressing objects: 100% (3/3), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. After that, you should see a subdirectory libcs1010 created in your current directory. Inside, there should be a file called Makefile , and two subdirectories called include and src . To compile the library, run 1 make This should compile the file src/cs1010.c and create a static C library named libcs1010.a under the lib directory.","title":"Installing the Library"},{"location":"messages.html","text":"Common clang Errors and Warnings Here is the list of common clang errors and warnings that you may encounter. We will expand this list over the semester. How to Read the Messages clang messages always start with the name of the file, the line number, and the character position. For instance, 1 error.c:3:5: error: use of undeclared identifier 'x' shows the error in the file error.c , line 3, position 5. In vim , you can use :<line number> to jump directly to the line containing this error. Variables Error: Use of undeclared identifier C is a static type language, and thus every variable used must be declared with its type. E.g., 1 2 3 4 int main () { x = 0 ; } would lead to the error 1 2 3 x.c:3:5: error: use of undeclared identifier 'x' x = 0; ^ In the example above, x is used by not declared. To fix, declare x with its type. E.g., 1 2 3 4 int main () { long x = 0 ; } Error: Redefinition of a variable Each variable should be declared exactly once within its scope (scoped by { and } ). E.g., 1 2 3 4 5 int main () { long x = 0 ; long x = 1 ; } Would give the error 1 2 3 4 5 6 x.c:4:10: error: redefinition of 'x' long x = 1; ^ x.c:3:10: note: previous definition is here long x = 0; ^ To fix, check whether you intend the second declaration to be the same variable (in which case, remove the declaration) or a new one (in which case, give it a different name). Warning: Unused Variable Declaring variables that are not used clutters the code. It is a good programming practice to only declare the variables that you need. CS1010 insists on this. If you declare variables that you end up not using, you will be penalized. 1 2 3 4 int main () { long x = 1 ; } Would result in 1 2 3 x.c:4:10: warning: unused variable 'x' [-Wunused-variable] long x = 1; ^ To fix, go through all such warnings and remove any variables that you declared/initialized but never used. Warning: Variable May Be Uninitialized A variable is uninitialized if it is declared but not assigned any value. This might lead to bugs in your code. 1 2 3 4 5 int main () { long y ; return y ; } Would result in 1 2 3 4 5 6 7 x.c:4:10: warning: variable 'y' is uninitialized when used here [-Wuninitialized] return y; ^ x.c:3:9: note: initialize the variable 'y' to silence this warning long y; ^ = 0 To fix, initialize the variable to appropriate value. Warning: Declarations shadows a local variable. Avoid naming a variable the same name as another variable in the outer scope. Doing so makes your code confusing to read. E.g., 1 2 3 4 5 6 int main () { long x = 0 ; if ( x < 0 ) { long x = 1 ; } } causes the following warning: 1 2 3 4 5 6 x.c:4:10: warning: declaration shadows a local variable [-Wshadow] long x = 1; ^ x.c:2:8: note: previous declaration is here long x = 0; ^ Warning: No previous extern declaration for non-static variable A global variable is detected. The use of global variables is bug-prone and should be avoided. For instance, 1 2 3 4 int x ; int main () { x = 1 ; } would lead to 1 2 3 4 5 6 7 8 x.c:1:6: warning: no previous extern declaration for non-static variable 'x' [-Wmissing-variable-declarations] long x; ^ x.c:1:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit long x; ^ To fix, make the variable local and pass it around from function to function. Functions Warning: Type specifier missing Functions must have a return type declared. C, by default, treats all functions as returning int if the return type is not declared. It is, however, a good programming practice to always declare the return type explicitly, even if it is returning int . CS1010 insists on this and you will be penalized if you do not declare the return type. E.g., 1 2 3 main () { } would give the warning 1 2 3 x.c:1:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int] main() ^ Warning: Implicit declaration of function All functions in C must be declared before they are used. If the function is defined elsewhere, the header file containing the function declaration should be included. Without the function declaration, the compile will guess the type of the arguments and its return type. An incorrect guess would lead to buggy code and thus should be avoided. E.g., 1 2 3 4 main () { sqrt ( 4 ); } would give the warning 1 2 3 4 x.c:3:4: warning: implicitly declaring library function 'sqrt' with type 'double (double)' [-Wimplicit-function-declaration] sqrt(4); ^ To fix, include the appropriate header file. Error: Undefined reference to a function This error is usually accompanied by an \"implicit declaration of function\" warning. During linking, clang tries to locate the definition of a function. Calling a function that is not defined would lead to the error above. E.g., 1 2 3 int main () { foo (); } would give the error: 1 2 3 /tmp/x-edd854.o: In function `main': x.c:(.text+0xb): undefined reference to `foo' clang: error: linker command failed with exit code 1 (use -v to see invocation)u Error: Too many/few arguments to a function call Each function should be called with exactly the number of arguments defined. E.g., 1 2 3 4 5 #include <math.h> int main () { sqrt (); } would lead to: 1 2 3 x.c:4:10: error: too few arguments to function call, single argument '__x' was not specified sqrt(); ~~~~ ^ To fix, check the documentation or the man page of the function you are calling to understand the number of arguments needed. Warning: Control reaches the end of non-void function Every non-void function, except main , must return a value. If you define a non-void function but did not include a return statement, the compiler would warn you. Failing the return the intended value means the caller would not receive the correct value back, leading to a buggy code. E.g., 1 2 3 int foo () { } would lead to the warning: 1 2 x.c:3:1: warning: control reaches end of non-void function [-Wreturn-type] } To fix this, double-check if the function needs to return anything. If not, change the return type to void . Otherwise, return the appropriate value. Warning: Parameter is not declared, defaulting to type int The type of each parameter to a function must be declared explicitly. Not doing so would lead to code that is cognitively harder to understand and bug-prone than necessary. For example, 1 2 3 int foo ( x ) { return x ; } would give 1 2 3 x.c:1:9: warning: parameter 'x' was not declared, defaulting to type 'int' [-Wpedantic] int foo(x) { ^ To fix, declare an appropriate type for each parameter. Warning: Unused Parameter Every parameter that you pass into a function must serve a purpose and so should be used. For instance, 1 2 3 int foo ( long x ) { return 0 ; } leads to the warning: 1 2 3 x.c:1:14: warning: unused parameter 'x' [-Wunused-parameter] int foo(long x) { ^ To fix, either remove the parameter x if you do not need it or check that you do not unintentionally leave x unused. Logic Warning: Expression result unused The result of your expression should be used. Otherwise, the computation is wasted. For instance: 1 2 3 4 int main () { long x = 0 ; x + 2 ; } causes the warning: 1 2 3 x.c:3:5: warning: expression result unused [-Wunused-value] x + 2; ~ ^ ~ To fix, check the expression is necessary. If so, use it as intended. Otherwise, remove it. Warning: Code/return/break will never be executed The execution flow of your code is incorrect. Part of the code will never be executed and is redundant. 1 2 3 4 5 int main () { long x ; return 0 ; x = 1 ; } causes the warning: 1 2 3 x.c:4:7: warning: code will never be executed [-Wunreachable-code] x = 1; ^ To fix, check the logic of your code and remove redundant code. Warning: Comparing floating point with == or != is unsafe Floating numbers should never be compared with == operator since the representation is not precise. 1 2 3 4 void foo ( double x ) { if ( x == 0.03 ) { } } causes the warning 1 2 3 x.c:2:9: warning: comparing floating point with == or != is unsafe [-Wfloat-equal] if (x == 0.03) { ~ ^ ~~~~ To fix this, use > and < comparison with a small error. For instance, 1 2 if ( x > 0.003 - EPSILON && x < 0.003 + EPSILON ) { } where EPSILON is a very small number.","title":"Compiler Messages"},{"location":"messages.html#common-clang-errors-and-warnings","text":"Here is the list of common clang errors and warnings that you may encounter. We will expand this list over the semester.","title":"Common clang Errors and Warnings"},{"location":"messages.html#how-to-read-the-messages","text":"clang messages always start with the name of the file, the line number, and the character position. For instance, 1 error.c:3:5: error: use of undeclared identifier 'x' shows the error in the file error.c , line 3, position 5. In vim , you can use :<line number> to jump directly to the line containing this error.","title":"How to Read the Messages"},{"location":"messages.html#variables","text":"","title":"Variables"},{"location":"messages.html#error-use-of-undeclared-identifier","text":"C is a static type language, and thus every variable used must be declared with its type. E.g., 1 2 3 4 int main () { x = 0 ; } would lead to the error 1 2 3 x.c:3:5: error: use of undeclared identifier 'x' x = 0; ^ In the example above, x is used by not declared. To fix, declare x with its type. E.g., 1 2 3 4 int main () { long x = 0 ; }","title":"Error: Use of undeclared identifier"},{"location":"messages.html#error-redefinition-of-a-variable","text":"Each variable should be declared exactly once within its scope (scoped by { and } ). E.g., 1 2 3 4 5 int main () { long x = 0 ; long x = 1 ; } Would give the error 1 2 3 4 5 6 x.c:4:10: error: redefinition of 'x' long x = 1; ^ x.c:3:10: note: previous definition is here long x = 0; ^ To fix, check whether you intend the second declaration to be the same variable (in which case, remove the declaration) or a new one (in which case, give it a different name).","title":"Error: Redefinition of a variable"},{"location":"messages.html#warning-unused-variable","text":"Declaring variables that are not used clutters the code. It is a good programming practice to only declare the variables that you need. CS1010 insists on this. If you declare variables that you end up not using, you will be penalized. 1 2 3 4 int main () { long x = 1 ; } Would result in 1 2 3 x.c:4:10: warning: unused variable 'x' [-Wunused-variable] long x = 1; ^ To fix, go through all such warnings and remove any variables that you declared/initialized but never used.","title":"Warning: Unused Variable"},{"location":"messages.html#warning-variable-may-be-uninitialized","text":"A variable is uninitialized if it is declared but not assigned any value. This might lead to bugs in your code. 1 2 3 4 5 int main () { long y ; return y ; } Would result in 1 2 3 4 5 6 7 x.c:4:10: warning: variable 'y' is uninitialized when used here [-Wuninitialized] return y; ^ x.c:3:9: note: initialize the variable 'y' to silence this warning long y; ^ = 0 To fix, initialize the variable to appropriate value.","title":"Warning: Variable May Be Uninitialized"},{"location":"messages.html#warning-declarations-shadows-a-local-variable","text":"Avoid naming a variable the same name as another variable in the outer scope. Doing so makes your code confusing to read. E.g., 1 2 3 4 5 6 int main () { long x = 0 ; if ( x < 0 ) { long x = 1 ; } } causes the following warning: 1 2 3 4 5 6 x.c:4:10: warning: declaration shadows a local variable [-Wshadow] long x = 1; ^ x.c:2:8: note: previous declaration is here long x = 0; ^","title":"Warning: Declarations shadows a local variable."},{"location":"messages.html#warning-no-previous-extern-declaration-for-non-static-variable","text":"A global variable is detected. The use of global variables is bug-prone and should be avoided. For instance, 1 2 3 4 int x ; int main () { x = 1 ; } would lead to 1 2 3 4 5 6 7 8 x.c:1:6: warning: no previous extern declaration for non-static variable 'x' [-Wmissing-variable-declarations] long x; ^ x.c:1:1: note: declare 'static' if the variable is not intended to be used outside of this translation unit long x; ^ To fix, make the variable local and pass it around from function to function.","title":"Warning: No previous extern declaration for non-static variable"},{"location":"messages.html#functions","text":"","title":"Functions"},{"location":"messages.html#warning-type-specifier-missing","text":"Functions must have a return type declared. C, by default, treats all functions as returning int if the return type is not declared. It is, however, a good programming practice to always declare the return type explicitly, even if it is returning int . CS1010 insists on this and you will be penalized if you do not declare the return type. E.g., 1 2 3 main () { } would give the warning 1 2 3 x.c:1:1: warning: type specifier missing, defaults to 'int' [-Wimplicit-int] main() ^","title":"Warning: Type specifier missing"},{"location":"messages.html#warning-implicit-declaration-of-function","text":"All functions in C must be declared before they are used. If the function is defined elsewhere, the header file containing the function declaration should be included. Without the function declaration, the compile will guess the type of the arguments and its return type. An incorrect guess would lead to buggy code and thus should be avoided. E.g., 1 2 3 4 main () { sqrt ( 4 ); } would give the warning 1 2 3 4 x.c:3:4: warning: implicitly declaring library function 'sqrt' with type 'double (double)' [-Wimplicit-function-declaration] sqrt(4); ^ To fix, include the appropriate header file.","title":"Warning: Implicit declaration of function"},{"location":"messages.html#error-undefined-reference-to-a-function","text":"This error is usually accompanied by an \"implicit declaration of function\" warning. During linking, clang tries to locate the definition of a function. Calling a function that is not defined would lead to the error above. E.g., 1 2 3 int main () { foo (); } would give the error: 1 2 3 /tmp/x-edd854.o: In function `main': x.c:(.text+0xb): undefined reference to `foo' clang: error: linker command failed with exit code 1 (use -v to see invocation)u","title":"Error: Undefined reference to a function"},{"location":"messages.html#error-too-manyfew-arguments-to-a-function-call","text":"Each function should be called with exactly the number of arguments defined. E.g., 1 2 3 4 5 #include <math.h> int main () { sqrt (); } would lead to: 1 2 3 x.c:4:10: error: too few arguments to function call, single argument '__x' was not specified sqrt(); ~~~~ ^ To fix, check the documentation or the man page of the function you are calling to understand the number of arguments needed.","title":"Error: Too many/few arguments to a function call"},{"location":"messages.html#warning-control-reaches-the-end-of-non-void-function","text":"Every non-void function, except main , must return a value. If you define a non-void function but did not include a return statement, the compiler would warn you. Failing the return the intended value means the caller would not receive the correct value back, leading to a buggy code. E.g., 1 2 3 int foo () { } would lead to the warning: 1 2 x.c:3:1: warning: control reaches end of non-void function [-Wreturn-type] } To fix this, double-check if the function needs to return anything. If not, change the return type to void . Otherwise, return the appropriate value.","title":"Warning: Control reaches the end of non-void function"},{"location":"messages.html#warning-parameter-is-not-declared-defaulting-to-type-int","text":"The type of each parameter to a function must be declared explicitly. Not doing so would lead to code that is cognitively harder to understand and bug-prone than necessary. For example, 1 2 3 int foo ( x ) { return x ; } would give 1 2 3 x.c:1:9: warning: parameter 'x' was not declared, defaulting to type 'int' [-Wpedantic] int foo(x) { ^ To fix, declare an appropriate type for each parameter.","title":"Warning: Parameter is not declared, defaulting to type int"},{"location":"messages.html#warning-unused-parameter","text":"Every parameter that you pass into a function must serve a purpose and so should be used. For instance, 1 2 3 int foo ( long x ) { return 0 ; } leads to the warning: 1 2 3 x.c:1:14: warning: unused parameter 'x' [-Wunused-parameter] int foo(long x) { ^ To fix, either remove the parameter x if you do not need it or check that you do not unintentionally leave x unused.","title":"Warning: Unused Parameter"},{"location":"messages.html#logic","text":"","title":"Logic"},{"location":"messages.html#warning-expression-result-unused","text":"The result of your expression should be used. Otherwise, the computation is wasted. For instance: 1 2 3 4 int main () { long x = 0 ; x + 2 ; } causes the warning: 1 2 3 x.c:3:5: warning: expression result unused [-Wunused-value] x + 2; ~ ^ ~ To fix, check the expression is necessary. If so, use it as intended. Otherwise, remove it.","title":"Warning: Expression result unused"},{"location":"messages.html#warning-codereturnbreak-will-never-be-executed","text":"The execution flow of your code is incorrect. Part of the code will never be executed and is redundant. 1 2 3 4 5 int main () { long x ; return 0 ; x = 1 ; } causes the warning: 1 2 3 x.c:4:7: warning: code will never be executed [-Wunreachable-code] x = 1; ^ To fix, check the logic of your code and remove redundant code.","title":"Warning: Code/return/break will never be executed"},{"location":"messages.html#warning-comparing-floating-point-with-or-is-unsafe","text":"Floating numbers should never be compared with == operator since the representation is not precise. 1 2 3 4 void foo ( double x ) { if ( x == 0.03 ) { } } causes the warning 1 2 3 x.c:2:9: warning: comparing floating point with == or != is unsafe [-Wfloat-equal] if (x == 0.03) { ~ ^ ~~~~ To fix this, use > and < comparison with a small error. For instance, 1 2 if ( x > 0.003 - EPSILON && x < 0.003 + EPSILON ) { } where EPSILON is a very small number.","title":"Warning: Comparing floating point with == or != is unsafe"},{"location":"midterm.html","text":"Midterm Important Information Date: 28 September 2020 (Monday) Time: 12noon to 2 pm Venue: Online Scope: Units 1-12, Assignments 1-2, Tutorials 1-4 Format: MCQs and Short Structured Questions Duration: 60 minutes Open Book (You can refer to printed/written notes but no online references are allowed) A calculator is allowed (although you do not need it) E-Exam Procedure We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010. 2.1 Exam Taking Software We will use Luminus Quiz for the midterm test. 2.2 Proctoring Protocol Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The browser running Luminuz Quiz running on your PC must be in full-screen mode. No other tabs are allowed on the browser. 2.4. Seeking Clarifications on Exam Questions You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\". 2.5. Multi-part Exam CS1010 midterm is only a single part with no break in between. Zoom Session Assignment Zoom session assignment is available internally via LumiNUS Zoom link available via Piazza Invigilators and Email Address Invigilators list available on Piazza","title":"Midterm"},{"location":"midterm.html#midterm","text":"","title":"Midterm"},{"location":"midterm.html#important-information","text":"Date: 28 September 2020 (Monday) Time: 12noon to 2 pm Venue: Online Scope: Units 1-12, Assignments 1-2, Tutorials 1-4 Format: MCQs and Short Structured Questions Duration: 60 minutes Open Book (You can refer to printed/written notes but no online references are allowed) A calculator is allowed (although you do not need it)","title":"Important Information"},{"location":"midterm.html#e-exam-procedure","text":"We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010.","title":"E-Exam Procedure"},{"location":"midterm.html#21-exam-taking-software","text":"We will use Luminus Quiz for the midterm test.","title":"2.1 Exam Taking Software"},{"location":"midterm.html#22-proctoring-protocol","text":"Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The browser running Luminuz Quiz running on your PC must be in full-screen mode. No other tabs are allowed on the browser.","title":"2.2 Proctoring Protocol"},{"location":"midterm.html#24-seeking-clarifications-on-exam-questions","text":"You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\".","title":"2.4. Seeking Clarifications on Exam Questions"},{"location":"midterm.html#25-multi-part-exam","text":"CS1010 midterm is only a single part with no break in between.","title":"2.5. Multi-part Exam"},{"location":"midterm.html#zoom-session-assignment","text":"Zoom session assignment is available internally via LumiNUS Zoom link available via Piazza","title":"Zoom Session Assignment"},{"location":"midterm.html#invigilators-and-email-address","text":"Invigilators list available on Piazza","title":"Invigilators and Email Address"},{"location":"outcomes.html","text":"After taking CS1010, students should be familiar with fundamental programming concepts and methodology (variables, assignments, conditions, branches, loops, functions, recursions, structures); be familiar with and appreciate good programming practice, and apply it to follow-up courses; be able to apply problem-solving knowledge and skills to write small, well-documented, effective C programs; be able to appreciate the use of simple data structure such as array, know their limitations to pave way for more complex data structures in the next course; know the responsibilities of an ethical programmer; be able to write simple programs in the corresponding programming language to solve a task, given the constraints on the inputs; be able to manually trace through a program to identify logical errors; be able to differentiate between logical errors, syntax errors, and run-time errors; be exposed informally to the concept of code specification in the form of comments in the code, explaining what are the expected inputs and outputs and what are the assumptions; know about what are some insecure functions to avoid; be able to generate test cases on their own, with a focus on boundary/special cases; be able to debug with printf or equivalent functions; be aware of common strategies and good practices of debugging with printf or equivalent functions; be able to identify opportunities to, and write, modularized code; be exposed to a debugger; be able to write code following good programming style (clear comments, naming convention, indentation, etc.); understand the different data types and that there exists a representation of each in the memory, as well as the limitation of the representations due to the limited number of bits; develop a simple mental model of how a program is executed (CPU runs the code on data that is stored in memory, function call leads to the creation of call frames, which can explain recursion and variable scoping, etc). For interpreted language, understand the role of virtual machine/interpreter; be able to understand at a high level the compilation process (from pre-processing to compiling to linking), where applicable; understand the concept of reusability and how a software application can be built on top of software libraries/packages (standard or third parties); be able to implement bubble sort and insertion sort; be able to implement linear search and binary search (both iterative and recursive versions);","title":"Learning Outcomes"},{"location":"pe1.html","text":"Practice Exam 1 Questions You can accept the PE1 questions on Github and run 1 ~cs1010/get-pe01 and 1 ~cs1010/submit-pe01 as usual, for practice. Basic Info Date: 3 October 2020 (Saturday) Time: 9 am to 12noon (Report to invigilator at 9 am, exam starts at 9:30am) Venue: Online (except those already informed) Scope: Units 1-12, Assignments 1-2, Tutorials 1-4 5 programming questions: from very easy to very hard Criteria: correctness and style. There will be one question where efficiency matters. Duration: 2 hours and 30 minutes Open Book (You can refer to printed/written materials, but no online resources are allowed). Special Restrictions You will be issued a special account for use on the day of the practical exam. This should already been sent to your NUS email account and you should have already tested it during Thursday's tutorial session. You will need to log into a special set of PE nodes through ssh to solve the exam questions. You are not allowed to use the Internet for other purposes. You are only allowed to (i) interact with the files on the PE nodes through ssh ; and (ii) communicate with the invigilators through Zoom. File transfer into the PE nodes is not allowed. Vim Configuration Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins. E-Exam Procedure We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010. 2.1 Exam Taking Software You will use a terminal to ssh into your allocated PE nodes to take the practical exam. 1 You can only access the PE nodes for examination through either SoC VPN or tunnels through sunfire. 2.2 Proctoring Protocol Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The terminal running on your PC must be in full-screen mode. Terminal window/tab other than the one used to connect to the PE nodes are not allowed. You are allowed only one full-screen terminal window. You may use split windows within vim to view the exam questions and your code side-by-side. If you need to switch to other Windows (e.g., Zoom chat to ask question), you need to get permission from the invigilator. 2.4. Seeking Clarifications on Exam Questions You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\". 2.5. Multi-part Exam There is only a single part with no break in between. 9.6. Completion of Exam The folder to submit the your recording to is LumiNUS> CS1010 > Files > PE1 Screen Capture Video Submissiona. You should submit it no later than 3 October 2020, 2359. Note that failure to submit equates to you not being proctored for Practical Examination 1. Zoom Session Assignment Please see https://piazza.com/class/kdgunoizhic105?cid=381 Invigilators Please see https://piazza.com/class/kdgunoizhic105?cid=381 Emergency Contact (Examination issues) Zoom Chat (when permission is given by the proctor) If Zoom fails, MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors Find Proctor and Instructor Email Information on LumiNUS > CS1010 > Module Details > Facilitators (Top Menu) (note down the email before the exam in case Luminus fails) Emergency Contact for Technical Issues School of Computing - Technical Services Telephone: 6516 2736 Email: techsvc@comp.nus.edu.sg Emergency Telephone: 6874 2736 (available only during emergencies and network outages) General Advice Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? What is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so. Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases. Practice Paper You can use the PE question from 18/19 Semester 1 as the practice paper. Download the question paper Accept the assignment on GitHub Run ~cs1010/get-pe18 on any PE host to get the skeleton code and test cases Run ~cs1010/submit-pe18 to submit/archive your solution on GitHub","title":"Practice Exam 1"},{"location":"pe1.html#practice-exam-1","text":"","title":"Practice Exam 1"},{"location":"pe1.html#questions","text":"You can accept the PE1 questions on Github and run 1 ~cs1010/get-pe01 and 1 ~cs1010/submit-pe01 as usual, for practice.","title":"Questions"},{"location":"pe1.html#basic-info","text":"Date: 3 October 2020 (Saturday) Time: 9 am to 12noon (Report to invigilator at 9 am, exam starts at 9:30am) Venue: Online (except those already informed) Scope: Units 1-12, Assignments 1-2, Tutorials 1-4 5 programming questions: from very easy to very hard Criteria: correctness and style. There will be one question where efficiency matters. Duration: 2 hours and 30 minutes Open Book (You can refer to printed/written materials, but no online resources are allowed).","title":"Basic Info"},{"location":"pe1.html#special-restrictions","text":"You will be issued a special account for use on the day of the practical exam. This should already been sent to your NUS email account and you should have already tested it during Thursday's tutorial session. You will need to log into a special set of PE nodes through ssh to solve the exam questions. You are not allowed to use the Internet for other purposes. You are only allowed to (i) interact with the files on the PE nodes through ssh ; and (ii) communicate with the invigilators through Zoom. File transfer into the PE nodes is not allowed.","title":"Special Restrictions"},{"location":"pe1.html#vim-configuration","text":"Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins.","title":"Vim Configuration"},{"location":"pe1.html#e-exam-procedure","text":"We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010.","title":"E-Exam Procedure"},{"location":"pe1.html#21-exam-taking-software","text":"You will use a terminal to ssh into your allocated PE nodes to take the practical exam. 1 You can only access the PE nodes for examination through either SoC VPN or tunnels through sunfire.","title":"2.1 Exam Taking Software"},{"location":"pe1.html#22-proctoring-protocol","text":"Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The terminal running on your PC must be in full-screen mode. Terminal window/tab other than the one used to connect to the PE nodes are not allowed. You are allowed only one full-screen terminal window. You may use split windows within vim to view the exam questions and your code side-by-side. If you need to switch to other Windows (e.g., Zoom chat to ask question), you need to get permission from the invigilator.","title":"2.2 Proctoring Protocol"},{"location":"pe1.html#24-seeking-clarifications-on-exam-questions","text":"You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\".","title":"2.4. Seeking Clarifications on Exam Questions"},{"location":"pe1.html#25-multi-part-exam","text":"There is only a single part with no break in between.","title":"2.5. Multi-part Exam"},{"location":"pe1.html#96-completion-of-exam","text":"The folder to submit the your recording to is LumiNUS> CS1010 > Files > PE1 Screen Capture Video Submissiona. You should submit it no later than 3 October 2020, 2359. Note that failure to submit equates to you not being proctored for Practical Examination 1.","title":"9.6. Completion of Exam"},{"location":"pe1.html#zoom-session-assignment","text":"Please see https://piazza.com/class/kdgunoizhic105?cid=381","title":"Zoom Session Assignment"},{"location":"pe1.html#invigilators","text":"Please see https://piazza.com/class/kdgunoizhic105?cid=381","title":"Invigilators"},{"location":"pe1.html#emergency-contact-examination-issues","text":"Zoom Chat (when permission is given by the proctor) If Zoom fails, MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors Find Proctor and Instructor Email Information on LumiNUS > CS1010 > Module Details > Facilitators (Top Menu) (note down the email before the exam in case Luminus fails)","title":"Emergency Contact (Examination issues)"},{"location":"pe1.html#emergency-contact-for-technical-issues","text":"School of Computing - Technical Services Telephone: 6516 2736 Email: techsvc@comp.nus.edu.sg Emergency Telephone: 6874 2736 (available only during emergencies and network outages)","title":"Emergency Contact for Technical Issues"},{"location":"pe1.html#general-advice","text":"Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? What is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer for the first 10 minutes of the practical exam, or until the invigilator announced that you can do so. Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases.","title":"General Advice"},{"location":"pe1.html#practice-paper","text":"You can use the PE question from 18/19 Semester 1 as the practice paper. Download the question paper Accept the assignment on GitHub Run ~cs1010/get-pe18 on any PE host to get the skeleton code and test cases Run ~cs1010/submit-pe18 to submit/archive your solution on GitHub","title":"Practice Paper"},{"location":"pe2.html","text":"Practice Exam 2 Basic Info Date: 7 November 2020 (Saturday) Time: 9 am to 12noon (Report to invigilator at 9 am, exam starts at 9:30am) Venue: Online Scope: Units 1-27, Assignments 1-8, Tutorials 1-10 5 programming questions: from very easy to very hard Criteria: correctness, style, efficiency, and documentation. These are applied differently to different question (e.g., efficiency is important only for some questions, documentation is required only for some questions). Duration: 2 hours and 30 minutes Open Book (You can refer to printed/written materials, but no online resources are allowed). Special Restrictions You will be issued a special account for use on the day of the practical exam. This will been sent to your NUS email account and you should will get a chance to test it during Thursday's tutorial session. You will need to log into a special set of PE nodes through ssh to solve the exam questions. You are not allowed to use the Internet for other purposes. You are only allowed to (i) interact with the files on the PE nodes through ssh ; and (ii) communicate with the invigilators through Zoom. File transfer into the PE nodes is not allowed. Vim Configuration Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins. E-Exam Procedure We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010. 2.1 Exam Taking Software You will use a terminal to ssh into your allocated PE nodes to take the practical exam. 1 You can only access the PE nodes for examination through either SoC VPN or tunnels through sunfire. 2.2 Proctoring Protocol Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The terminal running on your PC must be in full-screen mode. Terminal window/tab other than the one used to connect to the PE nodes are not allowed. You are allowed only one full-screen terminal window. You may use split windows within vim to view the exam questions and your code side-by-side. If you need to switch to other Windows (e.g., Zoom chat to ask question), you need to get permission from the invigilator. Do note that failure to comply with proctoring requirements may require you to retake PE2 2.4. Seeking Clarifications on Exam Questions You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\". 2.5. Multi-part Exam There is only a single part with no break in between. 9.6. Completion of Exam The folder to submit the your recording to is LumiNUS> CS1010 > Files > PE2 Screen Capture Video Submission. You should submit it no later than 7 November 2020, 2359. Note that failure to submit equates to you not being proctored for Practical Examination 2. Zoom Session Assignment Group assignment is available on Luminus. Zoom sessions are available on Piazza Invigilators TBD Emergency Contact (Examination issues) Zoom Chat (when permission is given by the proctor) If Zoom fails, MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors Find Proctor and Instructor Email Information on LumiNUS > CS1010 > Module Details > Facilitators (Top Menu) (note down the email before the exam in case Luminus fails) Emergency Contact for Technical Issues School of Computing - Technical Services Telephone: 6516 2736 Email: techsvc@comp.nus.edu.sg Emergency Telephone: 6874 2736 (available only during emergencies and network outages) General Advice Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? What is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer until the invigilator announced that you can do so. Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases. Practice Paper You can use the PE question from 18/19 Semester 1 as the practice paper. Download the question paper Accept the assignment on GitHub Run ~cs1010/get-pe19 on any PE host to get the skeleton code and test cases Run ~cs1010/submit-pe19 to submit/archive your solution on GitHub","title":"Practice Exam 2"},{"location":"pe2.html#practice-exam-2","text":"","title":"Practice Exam 2"},{"location":"pe2.html#basic-info","text":"Date: 7 November 2020 (Saturday) Time: 9 am to 12noon (Report to invigilator at 9 am, exam starts at 9:30am) Venue: Online Scope: Units 1-27, Assignments 1-8, Tutorials 1-10 5 programming questions: from very easy to very hard Criteria: correctness, style, efficiency, and documentation. These are applied differently to different question (e.g., efficiency is important only for some questions, documentation is required only for some questions). Duration: 2 hours and 30 minutes Open Book (You can refer to printed/written materials, but no online resources are allowed).","title":"Basic Info"},{"location":"pe2.html#special-restrictions","text":"You will be issued a special account for use on the day of the practical exam. This will been sent to your NUS email account and you should will get a chance to test it during Thursday's tutorial session. You will need to log into a special set of PE nodes through ssh to solve the exam questions. You are not allowed to use the Internet for other purposes. You are only allowed to (i) interact with the files on the PE nodes through ssh ; and (ii) communicate with the invigilators through Zoom. File transfer into the PE nodes is not allowed.","title":"Special Restrictions"},{"location":"pe2.html#vim-configuration","text":"Your default account will have the same .vimrc as ~cs1010/.vimrc on the CS1010 PE hosts. You are free to edit this during the practical exams. You, however, will not be able to download nor install vim plugins.","title":"Vim Configuration"},{"location":"pe2.html#e-exam-procedure","text":"We adopt the E-exam procedure for the School of Computing for CS1010. This is a long document with a lot of information. Please read through it carefully. Please set up the software and hardware needed for taking e-exams before the test so that your test-taking experience is as smooth as possible. Note the following supplementary information to complete the E-exam procedure above, specific to CS1010.","title":"E-Exam Procedure"},{"location":"pe2.html#21-exam-taking-software","text":"You will use a terminal to ssh into your allocated PE nodes to take the practical exam. 1 You can only access the PE nodes for examination through either SoC VPN or tunnels through sunfire.","title":"2.1 Exam Taking Software"},{"location":"pe2.html#22-proctoring-protocol","text":"Note that the following applies to CS1010: You are allowed to use only a single screen. If you\u2019re using an external monitor, the laptop screen must be switched off. The terminal running on your PC must be in full-screen mode. Terminal window/tab other than the one used to connect to the PE nodes are not allowed. You are allowed only one full-screen terminal window. You may use split windows within vim to view the exam questions and your code side-by-side. If you need to switch to other Windows (e.g., Zoom chat to ask question), you need to get permission from the invigilator. Do note that failure to comply with proctoring requirements may require you to retake PE2","title":"2.2 Proctoring Protocol"},{"location":"pe2.html#24-seeking-clarifications-on-exam-questions","text":"You are allowed to ask clarification questions during the exam. However, you may only ask a boolean yes/no question. For instance, you are not allowed to ask \"What can we assume about the input?\". You should rephrase it as \"Can we assume that the input is always positive?\". Our answers will only be in the form of \"yes\", \"no\", \"no comment\".","title":"2.4. Seeking Clarifications on Exam Questions"},{"location":"pe2.html#25-multi-part-exam","text":"There is only a single part with no break in between.","title":"2.5. Multi-part Exam"},{"location":"pe2.html#96-completion-of-exam","text":"The folder to submit the your recording to is LumiNUS> CS1010 > Files > PE2 Screen Capture Video Submission. You should submit it no later than 7 November 2020, 2359. Note that failure to submit equates to you not being proctored for Practical Examination 2.","title":"9.6. Completion of Exam"},{"location":"pe2.html#zoom-session-assignment","text":"Group assignment is available on Luminus. Zoom sessions are available on Piazza","title":"Zoom Session Assignment"},{"location":"pe2.html#invigilators","text":"TBD","title":"Invigilators"},{"location":"pe2.html#emergency-contact-examination-issues","text":"Zoom Chat (when permission is given by the proctor) If Zoom fails, MS Teams (when permission is given by the proctor) If Zoom/Teams fail, as a last resort, you may email the instructors/proctors Find Proctor and Instructor Email Information on LumiNUS > CS1010 > Module Details > Facilitators (Top Menu) (note down the email before the exam in case Luminus fails)","title":"Emergency Contact (Examination issues)"},{"location":"pe2.html#emergency-contact-for-technical-issues","text":"School of Computing - Technical Services Telephone: 6516 2736 Email: techsvc@comp.nus.edu.sg Emergency Telephone: 6874 2736 (available only during emergencies and network outages)","title":"Emergency Contact for Technical Issues"},{"location":"pe2.html#general-advice","text":"Save your program regularly. We will use setup every account with ~/.vimrc copied from ~cs1010/.vimrc . Thus, you can find the last saved version of your files under ~/.backup if you accidentally deleted your code. Plan your time properly. Do not spend excessive time on any task. Read through all questions and solved those that you are confident to solve first. There are five questions, from very easy to very hard. Solve as many as you can. I expect most students will be able to solve 3 out of the 5 questions within the time limit. There is one mark allocated to style for each question. As long as you keep your code clean, neat, and readable, you will get this one mark, almost for free. Review the CS1010 style guide so that you know what is expected in terms of coding style. Don't start typing your code right away. Think about the solution first -- what variables are needed? What is the control flow (using branches and loops)? Draw out the flowchart if it helps. Break down the problem into smaller ones if the problem is too complex to solve. You are not allowed to start typing on the computer until the invigilator announced that you can do so. Just like the assignments, you are not given all the test cases that we will be using during grading. Please test your code against additional test cases, especially for boundary cases.","title":"General Advice"},{"location":"pe2.html#practice-paper","text":"You can use the PE question from 18/19 Semester 1 as the practice paper. Download the question paper Accept the assignment on GitHub Run ~cs1010/get-pe19 on any PE host to get the skeleton code and test cases Run ~cs1010/submit-pe19 to submit/archive your solution on GitHub","title":"Practice Paper"},{"location":"policies.html","text":"Policies Email Communication Piazza is the preferred platform if you have questions to ask or issues to raise (either publicly to your classmates or privately to the instructors). But if you must use email, please use only your official NUS email for communication with the teaching staff -- either the one with @u.nus.edu or @comp.nus.edu.sg . Prefix your email subject with [CS1010] . If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate. Tutorial and Lab Sessions Attendance is not compulsory at NUS, but we do take attendance during the tutorial and lab sessions for contract tracing purposes. You should stick to your allocated time slot for labs and tutorials. If there is a strong reason for you to attend another session, please inform your tutor. Late Submissions All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not). For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%. For example, if an assessment that was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached). No submission will be accepted a week after the deadline. Discussions and Plagiarism We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate. NUS and School of Computing have a high standard of academic honesty and take any violation seriously. In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation. Please read the page Preventing Plagiarism from the school's website to familiarize yourself with the policy. I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism. Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally. Lecture Video The recorded zoom video will be recorded and posted online 1-2 days after the lecture. This will be done on a 'best effort' basis and lecture video will not be guaranteed to be available on time or at all. Posting of video lecture is meant to help students who attended the lecture to recap the content or to help those who are not able to attend the lecture due to unexpected circumstances. It does not mean that you should skip the lecture. Research has shown that the effect of over-reliance on lecture video is negative. Model Solutions and Slides Slides will be posted after the class. Note that slides are used as a visual aid to assist me during the lectures. It is not meant as a summary of lectures nor a replacement of lecture notes. In a module like CS1010, there is often not a single correct answer. Hence, there is no model solution for this module. Sample solutions may be posted (both good and bad ones) for discussion. I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution. Grading Students will receive the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve). In other words, the number of As and Fs will not be artificially capped. Open Book Assessment All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other analog reference materials. There is nothing to memorize for this class.","title":"Policies"},{"location":"policies.html#policies","text":"","title":"Policies"},{"location":"policies.html#email-communication","text":"Piazza is the preferred platform if you have questions to ask or issues to raise (either publicly to your classmates or privately to the instructors). But if you must use email, please use only your official NUS email for communication with the teaching staff -- either the one with @u.nus.edu or @comp.nus.edu.sg . Prefix your email subject with [CS1010] . If you email us privately and we feel that your questions/answers are useful to the rest of the class, we will publish it on Piazza, with anonymization when appropriate.","title":"Email Communication"},{"location":"policies.html#tutorial-and-lab-sessions","text":"Attendance is not compulsory at NUS, but we do take attendance during the tutorial and lab sessions for contract tracing purposes. You should stick to your allocated time slot for labs and tutorials. If there is a strong reason for you to attend another session, please inform your tutor.","title":"Tutorial and Lab Sessions"},{"location":"policies.html#late-submissions","text":"All programming assignments must be submitted on time. If you need an extension, please ask for one and provide a justification for approval. Only academic reasons and compassionate reasons can be considered (e.g., representing NUS for a sports event is OK; Attending a wedding is not). For late submission, there is a 1% penalty (of the total assessment grade) for every 5-minutes after the deadline, capped at 80%. For example, if an assessment that was given 40 marks was submitted 100 minutes after the deadline, the student will get 32 marks instead (20% penalty). If it is submitted 10 hours after the deadline, the student will get 8 marks (as the cap of 80% penalty has been reached). No submission will be accepted a week after the deadline.","title":"Late Submissions"},{"location":"policies.html#discussions-and-plagiarism","text":"We encourage discussions among students for programming assignments, but each student should be responsible for writing his/her own code and should give credits to others when appropriate. NUS and School of Computing have a high standard of academic honesty and take any violation seriously. In the context of computing modules, source code plagiarism -- copying code from another source and attributing it as one's own code -- is a serious violation. Please read the page Preventing Plagiarism from the school's website to familiarize yourself with the policy. I adopt a \"no mercy\" policy when it comes to disciplinary action on plagiarism. Both parties, the student who copied, and the student who allowed others to copy, will be penalized equally.","title":"Discussions and Plagiarism"},{"location":"policies.html#lecture-video","text":"The recorded zoom video will be recorded and posted online 1-2 days after the lecture. This will be done on a 'best effort' basis and lecture video will not be guaranteed to be available on time or at all. Posting of video lecture is meant to help students who attended the lecture to recap the content or to help those who are not able to attend the lecture due to unexpected circumstances. It does not mean that you should skip the lecture. Research has shown that the effect of over-reliance on lecture video is negative.","title":"Lecture Video"},{"location":"policies.html#model-solutions-and-slides","text":"Slides will be posted after the class. Note that slides are used as a visual aid to assist me during the lectures. It is not meant as a summary of lectures nor a replacement of lecture notes. In a module like CS1010, there is often not a single correct answer. Hence, there is no model solution for this module. Sample solutions may be posted (both good and bad ones) for discussion. I strongly encourage students to discuss your solution with the teaching team, instead of just comparing your solution with the sample solution.","title":"Model Solutions and Slides"},{"location":"policies.html#grading","text":"Students will receive the grades they deserve irrespective of how the other students in the class perform (i.e., no bell curve). In other words, the number of As and Fs will not be artificially capped.","title":"Grading"},{"location":"policies.html#open-book-assessment","text":"All assessment, including practical exams, midterm test, and final assessment, are open book assessment -- you can bring in your notes or other analog reference materials. There is nothing to memorize for this class.","title":"Open Book Assessment"},{"location":"readings.html","text":"Readings Must Read How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio. Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again).. Best Teacher I Ever Had , by David Owen. Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, .. Why C? Learn C programming and the rest will come, by Marty Jacobs The Resurgence of C Programming, by Mark Barlow You Can't Dig Upwards, by Evan Miller Vim Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\" Vim Video Tutorial (from Aaron Tan) Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"Readings"},{"location":"readings.html#readings","text":"","title":"Readings"},{"location":"readings.html#must-read","text":"How NOT to Go About a Programming Assignment , by Agustin Cernuda del Rio. Computer programming students invariably fall into more than one bad habit. It can be extremely difficult to eradicate them (and many lecturers and professional programmers keep succumbing to them time and again).. Best Teacher I Ever Had , by David Owen. Mr. Whitson taught sixth-grade science. On the first day of class, he gave us a lecture about a creature called the cattywampus, ..","title":"Must Read"},{"location":"readings.html#why-c","text":"Learn C programming and the rest will come, by Marty Jacobs The Resurgence of C Programming, by Mark Barlow You Can't Dig Upwards, by Evan Miller","title":"Why C?"},{"location":"readings.html#vim","text":"Time to Drop Emacs and Vi? on StackOverflow. \" Programmers are notorious for using the tools that helps them get the job done in the most efficient way possible. These editors are ancient yet still being used because they are good, solid editors, proven by time. If they get the job done and get the job done well, why should we drop them in favor of something else? \" What are the benefits of learning Vim? on Stack Overflow. \" Usually vim's killer features are considered: A) that it's available on pretty much every Unix you'll ever encounter and B) your fingers very rarely have to leave the home row, which means you'll be able to edit text very, very quickly. It's also usually very fast and lightweight even when editing huge files. \" Learn vim Progressively \" I suggest you teach yourself Vim in 4 steps: 1. Survive. 2. Feel comfortable. 3. Feel Better, Stronger, Faster. 4. Use superpowers of vim \" Where Vim Came From -- from TwoBitHistory. \" Perhaps more importantly, while we\u2019re asking questions, why does exiting Vim involve typing :wq? Sure, it\u2019s a \u201cwrite\u201d operation followed by a \u201cquit\u201d operation, but that is not a particularly intuitive convention. Who decided that copying text should instead be called \u201cyanking\u201d? Why is :%s/foo/bar/gc short for \u201cfind and replace\u201d? Vim\u2019s idiosyncrasies seem too arbitrary to have been made up, but then where did they come from?\" Vim's Big Idea - by Mike Kozlowski. \"This philosophy of minimalist commands that can be composed together is the fundamental originating philosophy of Unix, and Vim exemplifies it like no other editor.\" VIM Pays Excellent Dividends - by John Bjorn Nelson. \"Being conservative, let\u2019s say it makes you 5% more productive. More specifically\u200a\u2014\u200aonce your brain maps the keystrokes to muscle memory\u200a\u2014\u200ait makes you 5% faster at completing the mundane tasks\u2026the ones which dominate programming. That added productivity snowballs. It\u2019s an extra twenty minutes a day to build or explore (or learn), that used to go to copy/paste-like operations.\" The Powers of VIM - by Artem Dudarev The 11 Steps to Learning Vim - by damassi . \"Regardless of the initial confusion and difficulty in getting started, you're making your future developer self immensely more productive by diving in and taking the plunge. Seriously. I'm just a few weeks in right now and I can positively say that learning Vim has been the best work-related decision of my life. It's fun, and in the strangest of ways it makes you think better.\" Vim for People Who Think Things like Vim and Weird and Hard - by Harry Roberts . \"the fact that, yes, people still use an editor that is over 20 years old (in turn based on a tool from the 70s), and those people number in the hundreds of thousands, perhaps they might be onto something.\" Why I use Vim - Pascal Precht. \"_once I was able to do some basic operations in Vim and actually started working again, I made almost as twice as much progress at work in about half the time. I know that sounds kind of crazy but I\u2019m serious. And that convinced me that I made the right choice. So, do yourself a favor and climb that mountain. Just remember that you can slide down afterwards._\"","title":"Vim"},{"location":"readings.html#vim-video-tutorial-from-aaron-tan","text":"Lesson 1 Lesson 2 Lesson 3 Lesson 4","title":"Vim Video Tutorial (from Aaron Tan)"},{"location":"schedule.html","text":"Schedule This is the schedule for CS1010. Note: Assignments are released on Thursday and due the following Tuesday 23:59. Catch-up sessions are optional review + Q&A sessions meant for students who need time to recap and catch up. They are held on Saturday morning 10 am to 12noon Practical exams are held on Saturday morning from 9 am to 12noon Midterm is held during the lecture slot. The topics covered are tentative. Class Activities Week Starting.. Topics Assignment Catch Up Session / Practical Exam 1 2021-08-09 Computational Problem Solving 2 2021-08-16 Functions & Types 3 2021-08-23 Basic C programs CU1 4 2021-08-30 Conditionals AS1 5 2021-09-06 Loops AS2 6 2021-09-13 Memory, Array, Strings AS3 CU2 - 2021-09-20 Break 7 2021-09-27 Midterm AS4 PE1 8 2021-10-04 Call-by-Referece, nD-Array AS5 9 2021-10-11 Efficiency, Macro AS6 10 2021-10-18 Searching and Sorting AS7 CU3 11 2021-10-25 More recursion AS8 12 2021-11-01 Struct and I/O AS9 PE2 13 2021-11-08 Recap CU4","title":"Schedule"},{"location":"schedule.html#schedule","text":"This is the schedule for CS1010. Note: Assignments are released on Thursday and due the following Tuesday 23:59. Catch-up sessions are optional review + Q&A sessions meant for students who need time to recap and catch up. They are held on Saturday morning 10 am to 12noon Practical exams are held on Saturday morning from 9 am to 12noon Midterm is held during the lecture slot. The topics covered are tentative.","title":"Schedule"},{"location":"schedule.html#class-activities","text":"Week Starting.. Topics Assignment Catch Up Session / Practical Exam 1 2021-08-09 Computational Problem Solving 2 2021-08-16 Functions & Types 3 2021-08-23 Basic C programs CU1 4 2021-08-30 Conditionals AS1 5 2021-09-06 Loops AS2 6 2021-09-13 Memory, Array, Strings AS3 CU2 - 2021-09-20 Break 7 2021-09-27 Midterm AS4 PE1 8 2021-10-04 Call-by-Referece, nD-Array AS5 9 2021-10-11 Efficiency, Macro AS6 10 2021-10-18 Searching and Sorting AS7 CU3 11 2021-10-25 More recursion AS8 12 2021-11-01 Struct and I/O AS9 PE2 13 2021-11-08 Recap CU4","title":"Class Activities"},{"location":"style.html","text":"CS1010 C Style In CS1010, you should following the following style guide when you write your code for your graded homework and practical exams. We typically allocate a few marks for coding style (each assignment/exam may have different allocation). You will lose marks for violation of style. This guide is modified from past CS1010 style guide by Aaron Tan. Why Coding Style is Important Quote \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\" Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609. 1. Variable Declaration Each variable should be declared in its own line. 1 2 double weight ; // The weight of the baby double height ; // The height of the baby Avoid 1 double weight , height ; // Weight and height of the baby 2. Give Variables Descriptive Names This is the most important rule to follow. The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning. For example, int number_of_coins; is an appropriate variable but not int c; . Avoid using a single character for variable names. There are some exceptions, however, as shown below: If the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain). If the variable is a transient/temporary variable whose purpose is clear. -If the variable is a loop variable whose purpose is clear. 3. Shorten Variable Names with Naming Conventions Despite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example, MAX_LEN , num_of_elems , pcurr , table_num . However, do not invent your own abbreviation. For instance, names like nm_elemnts should be avoided. 4. Avoid Negated Variable or Function Names Negated variables often result in hard-to-read double-negatives in an expression like !is_not_err . So, avoid is_not_error , is_not_found , is_not_valid , cannot_open_file . Instead, we prefer is_error , is_found , is_valid , can_open_file etc. 5. Use #define to Define Constants for Magic Numbers Avoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example: Avoid: 1 2 3 for ( i = 0 ; i < 100 ; i += 1 ) { : } Prefer: 1 2 3 4 5 #define MAX_LEN 100 : for (i = 0; i < MAX_LEN; i += 1) { : } 6. Naming Conventions Constants All constant identifiers must be written in all caps and separated by an underscore _ . For instance MAX_ITERATIONS , MAX_LEN , GOLDEN_RATIO , COLOR_DEFAULT , PI . Variables and Functions Use lower case letters for variable names and function names, with multiple words separated by underscore _ . Example, cs1010_read_long , is_prime . 7. Use Consistent Indentation to Emphasize Block Structure The code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide). Every block that follows a for , while , if-else , do-while statement must be indented from its enclosing block. Comments within a block should follow the indentation level of its enclosing block. For example, 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { // Comments should be indented too while ( j != i ) { // More indented comments printf ( \"Hello \\n \" ); } } The following are the wrong ways to indent the comments. 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { // This comment should be indented and aligned with the while statement. while ( j != i ) { // This comment should be aligned with the printf statement. printf ( \"Hello \\n \" ); } } 8. Don't Mix Tabs and Spaces You must use only spaces in your code. Do not use tabs. You can add the configuration set expandtab to automatically expand any tab that you enter into spaces. 9. Spaces in if , else , for , while , do - while Statements Add a single space between the keywords if , else , for , while and the following parentheses and between the parentheses and next curly bracket. For instance: 1 2 3 for( ... ) { // not good for( ... ){ // not good for ( ... ) { // good 10. Spaces in Assignments Add a single space before and after = . 1 2 3 4 a=b; // no a= b; // no a =b; // no a = b; // OK! 11. Positions of Open and Close Braces There are two camps on the position of open braces. The following shows the \"trailing open braces\": 1 2 3 4 5 for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } The following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in: 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } Both styles are acceptable, but you should be consistent and should not mix both styles in a single program. For close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them. 12. Avoid Else After Return Adding an else after a return statement in the if block is unnecessary and increases the indentation level. If the last statement of the if block is a return statement, we should skip the else statement. 1 2 3 4 5 6 7 8 9 if ( x == 1 ) { return 10 ; } else { if ( y == 2 ) { return 13 ; } else { return 89 ; } } can be written as the following equivalent code: 1 2 3 4 5 6 7 8 if ( x == 1 ) { return 10 ; } if ( y == 2 ) { return 13 ; } return 89 ; } 13. Comment Major Code Segments Adequately Major segments of code should have explanatory comments. A major segment may be a loop block or a function block. You should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how. An \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments. For example, 1 2 3 4 // Check and reject out-of-bounds indices if ( k < 0 || k >= MAX_LEN ) { return -1 ; } 14. Avoid Superfluous Comments A comment such as: 1 i += 1 // add one to i serves no purpose, adds clutter to a program and does more harm than good. 15. Blank Lines It is good to add a blank line between two functions, or two long segments of code for readability. 1 2 3 4 5 6 7 8 9 // This function ... int f ( int x ) { // body } // This function ... int g ( double y ) { // body } 1 2 3 4 5 6 7 8 9 10 // Statements 1 to 10 belong to a sub-task statement1 ; statement2 ; : statement10 ; // Leave a blank line for readability statement11 ; statement12 ; : However, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present. 16. Long Lines If a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines. 1 if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040C ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102R || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101R || has_ma1311 || has_ma1506 || has_ma1508E )) is bad 1 2 3 4 if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040c ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102r || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101r || has_ma1311 || has_ma1506 || has_ma1508e )) is better.","title":"C Style Convention"},{"location":"style.html#cs1010-c-style","text":"In CS1010, you should following the following style guide when you write your code for your graded homework and practical exams. We typically allocate a few marks for coding style (each assignment/exam may have different allocation). You will lose marks for violation of style. This guide is modified from past CS1010 style guide by Aaron Tan.","title":"CS1010 C Style"},{"location":"style.html#why-coding-style-is-important","text":"Quote \"It is not merely a matter of aesthetics that programs should be written in a particular style. Rather there is a psychological basis for writing programs in a conventional manner: programmers have strong expectations that other programmers will follow these discourse rules. If the rules are violated, then the utility afforded by the expectations that programmers have built up over time is effectively nullified. The results from the experiments with novice and advanced student programmers and with professional programmers described in this paper provide clear support for these claims.\" Elliot Soloway and Kate Ehrlich. \"Empirical studies of programming knowledge.\" IEEE Transactions on Software Engineering 5 (1984): 595-609.","title":"Why Coding Style is Important"},{"location":"style.html#1-variable-declaration","text":"Each variable should be declared in its own line. 1 2 double weight ; // The weight of the baby double height ; // The height of the baby Avoid 1 double weight , height ; // Weight and height of the baby","title":"1. Variable Declaration"},{"location":"style.html#2-give-variables-descriptive-names","text":"This is the most important rule to follow. The name of a type, variable, function, constant should inform us of its purpose clearly without the readers having to guess or look up its meaning. For example, int number_of_coins; is an appropriate variable but not int c; . Avoid using a single character for variable names. There are some exceptions, however, as shown below: If the variable is the problem size and it is given in the task statement. For example, a problem dealing with n values, hence the variable may be called n (preferably with a comment to explain). If the variable is a transient/temporary variable whose purpose is clear. -If the variable is a loop variable whose purpose is clear.","title":"2. Give Variables Descriptive Names"},{"location":"style.html#3-shorten-variable-names-with-naming-conventions","text":"Despite the recommendation for descriptive names, identifiers can be short yet descriptive by using abbreviations and/or common naming conventions. For example, MAX_LEN , num_of_elems , pcurr , table_num . However, do not invent your own abbreviation. For instance, names like nm_elemnts should be avoided.","title":"3. Shorten Variable Names with Naming Conventions"},{"location":"style.html#4-avoid-negated-variable-or-function-names","text":"Negated variables often result in hard-to-read double-negatives in an expression like !is_not_err . So, avoid is_not_error , is_not_found , is_not_valid , cannot_open_file . Instead, we prefer is_error , is_found , is_valid , can_open_file etc.","title":"4. Avoid Negated Variable or Function Names"},{"location":"style.html#5-use-define-to-define-constants-for-magic-numbers","text":"Avoid direct use of magic numbers. Constant literals which have special meanings should be named and its named identifier should be used in its place. For example: Avoid: 1 2 3 for ( i = 0 ; i < 100 ; i += 1 ) { : } Prefer: 1 2 3 4 5 #define MAX_LEN 100 : for (i = 0; i < MAX_LEN; i += 1) { : }","title":"5. Use #define to Define Constants for Magic Numbers"},{"location":"style.html#6-naming-conventions","text":"","title":"6. Naming Conventions"},{"location":"style.html#constants","text":"All constant identifiers must be written in all caps and separated by an underscore _ . For instance MAX_ITERATIONS , MAX_LEN , GOLDEN_RATIO , COLOR_DEFAULT , PI .","title":"Constants"},{"location":"style.html#variables-and-functions","text":"Use lower case letters for variable names and function names, with multiple words separated by underscore _ . Example, cs1010_read_long , is_prime .","title":"Variables and Functions"},{"location":"style.html#7-use-consistent-indentation-to-emphasize-block-structure","text":"The code should be properly and neatly indented to emphasize the nested logical structure of the program. An indentation of 2 or 4 spaces is recommended (8 is too wide). Every block that follows a for , while , if-else , do-while statement must be indented from its enclosing block. Comments within a block should follow the indentation level of its enclosing block. For example, 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { // Comments should be indented too while ( j != i ) { // More indented comments printf ( \"Hello \\n \" ); } } The following are the wrong ways to indent the comments. 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { // This comment should be indented and aligned with the while statement. while ( j != i ) { // This comment should be aligned with the printf statement. printf ( \"Hello \\n \" ); } }","title":"7. Use Consistent Indentation to Emphasize Block Structure"},{"location":"style.html#8-dont-mix-tabs-and-spaces","text":"You must use only spaces in your code. Do not use tabs. You can add the configuration set expandtab to automatically expand any tab that you enter into spaces.","title":"8. Don't Mix Tabs and Spaces"},{"location":"style.html#9-spaces-in-if-else-for-while-do-while-statements","text":"Add a single space between the keywords if , else , for , while and the following parentheses and between the parentheses and next curly bracket. For instance: 1 2 3 for( ... ) { // not good for( ... ){ // not good for ( ... ) { // good","title":"9. Spaces in if, else, for, while, do-while Statements"},{"location":"style.html#10-spaces-in-assignments","text":"Add a single space before and after = . 1 2 3 4 a=b; // no a= b; // no a =b; // no a = b; // OK!","title":"10. Spaces in Assignments"},{"location":"style.html#11-positions-of-open-and-close-braces","text":"There are two camps on the position of open braces. The following shows the \"trailing open braces\": 1 2 3 4 5 for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } The following shows the \"leading open braces\". The leading open brace must be aligned with the block of the construct it is in: 1 2 3 4 5 6 7 for ( i = 0 ; i < 3 ; i += 1 ) { while ( j != i ) { printf ( \"Hello \\n \" ); } } Both styles are acceptable, but you should be consistent and should not mix both styles in a single program. For close braces, they should be leading close braces aligned with the block of the construct. Close braces should NOT be trailing as that would make it hard to spot them.","title":"11. Positions of Open and Close Braces"},{"location":"style.html#12-avoid-else-after-return","text":"Adding an else after a return statement in the if block is unnecessary and increases the indentation level. If the last statement of the if block is a return statement, we should skip the else statement. 1 2 3 4 5 6 7 8 9 if ( x == 1 ) { return 10 ; } else { if ( y == 2 ) { return 13 ; } else { return 89 ; } } can be written as the following equivalent code: 1 2 3 4 5 6 7 8 if ( x == 1 ) { return 10 ; } if ( y == 2 ) { return 13 ; } return 89 ; }","title":"12. Avoid Else After Return"},{"location":"style.html#13-comment-major-code-segments-adequately","text":"Major segments of code should have explanatory comments. A major segment may be a loop block or a function block. You should comment on complicated logic, expressions, or algorithms, explaining what you are doing in the code, including why and how. An \"if\" block with a complex condition or an expression that is hard to understand should have explanatory comments. For example, 1 2 3 4 // Check and reject out-of-bounds indices if ( k < 0 || k >= MAX_LEN ) { return -1 ; }","title":"13. Comment Major Code Segments Adequately"},{"location":"style.html#14-avoid-superfluous-comments","text":"A comment such as: 1 i += 1 // add one to i serves no purpose, adds clutter to a program and does more harm than good.","title":"14. Avoid Superfluous Comments"},{"location":"style.html#15-blank-lines","text":"It is good to add a blank line between two functions, or two long segments of code for readability. 1 2 3 4 5 6 7 8 9 // This function ... int f ( int x ) { // body } // This function ... int g ( double y ) { // body } 1 2 3 4 5 6 7 8 9 10 // Statements 1 to 10 belong to a sub-task statement1 ; statement2 ; : statement10 ; // Leave a blank line for readability statement11 ; statement12 ; : However, guard against the use of excessive blank lines. Double blank lines and triply blank lines, or more, should not be present.","title":"15. Blank Lines"},{"location":"style.html#16-long-lines","text":"If a line (be it a statement or a comment) is too long (more than 80 characters), do not let it run through the screen and wrap around. Instead, split it into a few lines. 1 if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040C ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102R || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101R || has_ma1311 || has_ma1506 || has_ma1508E )) is bad 1 2 3 4 if (( has_cs2010 || has_cs2020 || has_cs2040 || has_cs2040c ) && ( has_st1232 || has_st2131 || has_st2132 || has_st2334 ) && ( has_ma1102r || has_ma1505 || ( has_ma1511 && has_ma1512 ) || has_ma1521 ) && ( has_ma1101r || has_ma1311 || has_ma1506 || has_ma1508e )) is better.","title":"16. Long Lines"},{"location":"tmate.html","text":"tmate tmate is a tool that allows us to share our terminal with one another. It is an essential tool for us to run our labs online. To run tmate , type 1 $ tmate on the command prompt on any of the PE nodes. You should see that the screen is cleared, and a bar appears at the bottom of your screen with the word [tmate] . First Run The first time you run tmate , you will be asked to generate an SSH key. You can do this by running ssh-keygen and follow the instructions therein. Sharing Your Terminal With Someone After you started tmate , you can run: 1 $ tmate show-messages or 1 $ tmate showmsgs This will display a message similar to the following: 1 2 3 4 5 6 7 Sun Aug 23 10:37:06 2020 [tmate] Connecting to ssh.tmate.io... Sun Aug 23 10:37:06 2020 [tmate] Note: clear your terminal before sharing readonly access Sun Aug 23 10:37:06 2020 [tmate] web session read only: https://tmate.io/t/ro-fhVJJmuNzpy2qBmpaB6n6v3Cb Sun Aug 23 10:37:06 2020 [tmate] ssh session read only: ssh ro-fhVJJmuNzpy2qBmpaB6n6v3Cb@sgp1.tmate.io Sun Aug 23 10:37:06 2020 [tmate] web session: https://tmate.io/t/SDgPyXE9juTRJpb6ghpCvVrxE Sun Aug 23 10:37:06 2020 [tmate] ssh session: ssh SDgPyXE9juTRJpb6ghpCvVrxE@sgp1.tmate.io Sun Aug 23 10:37:26 2020 [tmate] tmate can be upgraded to 2.4.0. See https://tmate.io for a list of new features The most important lines are the Lines 3-6. If you want to show your terminal with someone else, but do not want to give them the control to type into your terminal, you can share the information about the read-only sessions on Line 3-4. If you want to let someone else type into your terminal, share Line 5-6 with them. Doing so with your tutors would be very helpful during the tutorial session. Keep your tmate sessions private Do not at any time, make these links public -- only share them with people you trust. Quitting tmate To exit from tmate , you just need to hit Ctrl + D on your tmate command prompt. This should bring you back to your usual command prompt (the bar labeling [tmate] should disappear).","title":"TMate"},{"location":"tmate.html#tmate","text":"tmate is a tool that allows us to share our terminal with one another. It is an essential tool for us to run our labs online. To run tmate , type 1 $ tmate on the command prompt on any of the PE nodes. You should see that the screen is cleared, and a bar appears at the bottom of your screen with the word [tmate] .","title":"tmate"},{"location":"tmate.html#first-run","text":"The first time you run tmate , you will be asked to generate an SSH key. You can do this by running ssh-keygen and follow the instructions therein.","title":"First Run"},{"location":"tmate.html#sharing-your-terminal-with-someone","text":"After you started tmate , you can run: 1 $ tmate show-messages or 1 $ tmate showmsgs This will display a message similar to the following: 1 2 3 4 5 6 7 Sun Aug 23 10:37:06 2020 [tmate] Connecting to ssh.tmate.io... Sun Aug 23 10:37:06 2020 [tmate] Note: clear your terminal before sharing readonly access Sun Aug 23 10:37:06 2020 [tmate] web session read only: https://tmate.io/t/ro-fhVJJmuNzpy2qBmpaB6n6v3Cb Sun Aug 23 10:37:06 2020 [tmate] ssh session read only: ssh ro-fhVJJmuNzpy2qBmpaB6n6v3Cb@sgp1.tmate.io Sun Aug 23 10:37:06 2020 [tmate] web session: https://tmate.io/t/SDgPyXE9juTRJpb6ghpCvVrxE Sun Aug 23 10:37:06 2020 [tmate] ssh session: ssh SDgPyXE9juTRJpb6ghpCvVrxE@sgp1.tmate.io Sun Aug 23 10:37:26 2020 [tmate] tmate can be upgraded to 2.4.0. See https://tmate.io for a list of new features The most important lines are the Lines 3-6. If you want to show your terminal with someone else, but do not want to give them the control to type into your terminal, you can share the information about the read-only sessions on Line 3-4. If you want to let someone else type into your terminal, share Line 5-6 with them. Doing so with your tutors would be very helpful during the tutorial session. Keep your tmate sessions private Do not at any time, make these links public -- only share them with people you trust.","title":"Sharing Your Terminal With Someone"},{"location":"tmate.html#quitting-tmate","text":"To exit from tmate , you just need to hit Ctrl + D on your tmate command prompt. This should bring you back to your usual command prompt (the bar labeling [tmate] should disappear).","title":"Quitting tmate"},{"location":"unix.html","text":"Basic UNIX Commands UNIX-based operating systems provide a command line to interact with the system: to create directories, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interact with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster. Connect to the Programming Environment (PE) If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. 1 ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and waits for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form 1 ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assume that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs in to the system. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given. pwd : Print Current Working directory pwd shows you which directory you are currently in 1 2 ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it. ls : LiSt files The ls list the files in the current working directory. 1 2 ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first log in, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\") mkdir : MaKe a subDIRectory The mkdir command creates a subdirectory with the given name in the current directory. 1 2 3 4 5 ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Ctrl + P for Command History Unix maintains a history of your previously executed UNIX commands, and you may use Ctrl + P and Ctrl + N to go through it. Press the Ctrl + P until you find a previously executed UNIX command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long UNIX command. cd : Change Directory To navigate in the directory tree, changing the current working directory from to another, we use the cd command. 1 2 ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. 1 2 ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return home, we can alternatively use cd .. . 1 2 ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$ rmdir : ReMove a subDIRectory rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. 1 2 3 4 5 ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/ cp : CoPy files 1 2 3 ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. 1 ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory. mv : MoVe or rename files mv can move files from one directory to another. 1 2 3 4 5 6 7 ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy a file hello.c from the parent directory to the current directory. mv can also be used to rename files. 1 2 3 ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 ooiwt@pe111:~/tut01$ mv h and press the Tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command. rm : ReMove files Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. 1 2 3 ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . 1 2 ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you set up your own UNIX OS, you should add this alias 1 alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: 1 2 alias mv = \"mv -i\" alias cp = \"cp -i\" cat : CATenate file content to the screen 1 ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) 1 ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit. man : Online MANual An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article. chmod : Changing UNIX File Permission It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: 1 chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: 1 chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwxrwxrwx , or from -rwxr--r-- to rwxr-xr-x , and so on. You get the idea. Another way to change the permission is to set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: 1 chmod 444 <file> To set the permission to -rw------- , run: 1 chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises. scp : Secure Copy Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: 1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, 1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well. Specifying A Path in UNIX In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: 1 cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . 1 cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. 1 cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: 1 cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: 1 cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: 1 cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any shell you like if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"UNIX"},{"location":"unix.html#basic-unix-commands","text":"UNIX-based operating systems provide a command line to interact with the system: to create directories, to manipulate files, to run certain applications. While these tasks can be done through a GUI interface, a command line is still useful because (i) it provides a simple way to interact with a remote system (only text are exchanged between the local and remote hosts instead of graphics); (ii) it is extremely flexible and provides many customization options; (iii) you can easily automate the sequence of commands to issue for repetitive tasks; and (iv) it is faster.","title":"Basic UNIX Commands"},{"location":"unix.html#connect-to-the-programming-environment-pe","text":"If you would like to follow the following examples, you should first ssh into one of the PE hosts provided. We will use pe111 in the following example. But feel free to use pe112 up to pe120 for your practice. You should read this guide to see how to access and connect to the environment. Once you are connected, you should see a prompt like this. 1 ooiwt@pe111:~$ This interface is provided by a UNIX bash -- this shell sits in a loop and waits for users to enter a command, then it interprets and executes the command. There are many versions of shells, the default shell for our PE is bash 1 . The following is adapted for CS1010 from the instructions created by Aaron Tan . Bugs are mine. The power of UNIX stems from the many commands it offers. The following are a few commonly used commands. This list is by no means exhaustive and you are urged to explore on your own. Note that UNIX commands are case-sensitive . All commands are to be entered after the UNIX prompt of the form 1 ooiwt@pe111:~$ ~ indicates that you are currently in your home directory. The following examples assume that user ooiwt is logged into pe111 . It might be good to understand the directory structure in UNIX, a multi-user system. The directory tree is shown below: Each user has his/her own home directory, which is where he/she will be automatically placed when he/she logs in to the system. The above figure shows where the home directory of the user ooiwt resides in the directory tree. The user ooiwt may create files or directories in his/her home directory, but not elsewhere unless permission is given.","title":"Connect to the Programming Environment (PE)"},{"location":"unix.html#pwd-print-current-working-directory","text":"pwd shows you which directory you are currently in 1 2 ooiwt@pe111:~$ pwd /home/o/ooiwt UNIX uses forward slash / to deliminate different parts of the directory structure. This is the same notation as URLs so you should already be familiar with it.","title":"pwd: Print Current Working directory"},{"location":"unix.html#ls-list-files","text":"The ls list the files in the current working directory. 1 2 ooiwt@pe111:~$ ls ooiwt@pe111:~$ If you do not have any regular files in your home directory, as you should when you first log in, you should immediately return to the bash prompt. Rule of Silence UNIX follows the rule of silence : programs should not print unnecessary output, to allow other programs and users to easily parse the output from one program. So, if ls has nothing to list, it will list nothing (as opposed to, say, printing \"This is an empty directory.\")","title":"ls: LiSt files"},{"location":"unix.html#mkdir-make-a-subdirectory","text":"The mkdir command creates a subdirectory with the given name in the current directory. 1 2 3 4 5 ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls tut01 ooiwt@pe111:~$ ls -F tut01/ Here, you create a directory called tut01 . Now, when you ls , you can see the directory listed. You may also use ls -F for more information ( -F is one of the many options / flags available for the ls command. To see a complete list of the options, refer to the man pages, i.e., man ls .) The slash / beside the filename tells you that the file is a directory (aka folder in Windows lingo). A normal file does not have a slash beside its name when \"ls -F\" is used. You may also use the ls -l command (hyphen el, not hyphen one) to display almost all the file information, include the size of the file and the date of modification. Use Ctrl + P for Command History Unix maintains a history of your previously executed UNIX commands, and you may use Ctrl + P and Ctrl + N to go through it. Press the Ctrl + P until you find a previously executed UNIX command. You may then press Enter to execute it or edit the command before executing it. This is handy when you need to repeatedly execute a long UNIX command.","title":"mkdir: MaKe a subDIRectory"},{"location":"unix.html#cd-change-directory","text":"To navigate in the directory tree, changing the current working directory from to another, we use the cd command. 1 2 ooiwt@pe111:~$ cd tut01 ooiwt@pe111:~/tut01$ Note that the prompt changes to ~/tut01 to indicate that you are now in the tut01 directory below your HOME directory. Entering cd alone brings you back to your HOME directory, i.e., the directory in which you started with when you first logged into the system. 1 2 ooiwt@pe111:~/tut01$ cd ooiwt@pe111:~$ Two dots .. refers to the parent directory. So, alternatively, for the case above, since we are only one level down from the HOME , to return home, we can alternatively use cd .. . 1 2 ooiwt@pe111:~/tut01$ cd .. ooiwt@pe111:~$","title":"cd: Change Directory"},{"location":"unix.html#rmdir-remove-a-subdirectory","text":"rmdir removes a subDIRectory in current directory -- note that a directory must be empty before it can be removed. 1 2 3 4 5 ooiwt@pe111:~$ rmdir tut01 ooiwt@pe111:~$ ls -F ooiwt@pe111:~$ mkdir tut01 ooiwt@pe111:~$ ls -F tut01/","title":"rmdir: ReMove a subDIRectory"},{"location":"unix.html#cp-copy-files","text":"1 2 3 ooiwt@pe111:~/tut01$ cp ~cs1010/tut01/hello.c . ooiwt@pe111:~/tut01$ ls hello.c The command above copies the file hello.c from the HOME of user cs1010 , under directory tut01 , to the current directory. If you want to copy the whole directory, use -r flag, where r stands for recursive copy. 1 ooiwt@pe111:~/tut01$ cp -r ~cs1010/tut01 . In the last command above, the single . refers to the current directory. The directory tut01 and everything under it will be copied to the current directory.","title":"cp: CoPy files"},{"location":"unix.html#mv-move-or-rename-files","text":"mv can move files from one directory to another. 1 2 3 4 5 6 7 ooiwt@pe111:~/tut01$ ls hello.c ooiwt@pe111:~/tut01$ mv hello.c .. ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ ls .. hello.c ooiwt@pe111:~/tut01$ mv ../hello.c . Here, we tell mv to copy a file hello.c from the parent directory to the current directory. mv can also be used to rename files. 1 2 3 ooiwt@pe111:~/tut01$ mv hello.c hello_world.c ooiwt@pe111:~/tut01$ ls hello_world.c Use TAB for Name Completion If you have a very long file name, you may use UNIX's filename completion feature to reduce typing. For instance, you may type: 1 ooiwt@pe111:~/tut01$ mv h and press the Tab key, and UNIX will complete the filename for you if there is only one filename with the prefix \"h\". Otherwise, it will fill up the filename to the point where you need to type in more characters for disambiguation. The Tab key can also complete the name of a command.","title":"mv: MoVe or rename files"},{"location":"unix.html#rm-remove-files","text":"Be careful with this command -- files deleted cannot be restored. There is no trash or recycled bin like in Mac or Windows. 1 2 3 ooiwt@pe111:~/tut01$ rm hello.c ooiwt@pe111:~/tut01$ ls ooiwt@pe111:~/tut01$ rm -rf * While Unix command line provides lots of flexibility and power, with great power comes great responsibility. Some of the commands are extremely dangerous. rm -rf * is the most famous one. The notation * refers to all files, and the flag -f means forceful deletion (no question asked!), and -r means remove recursively everything under the current directory tree. Accidentally running this command has ruined many files. Read more here rm comes with a -i flag that interactively asks you if you are sure if you want to delete a file. It is a good idea to always run rm -i . On pe111 , we have configured everyone's account so that rm is aliased to rm -i by default. So when you run rm hello.c , it actually runs rm -i hello.c . 1 2 ooiwt@pe111:~/tut01$ rm hello.c rm: remove regular file 'hello.c' ? Type y or n to answer yes or no respectively. If you set up your own UNIX OS, you should add this alias 1 alias rm = \"rm -i\" to your .bashrc (Google to find out how). Other useful aliases to avoid accidentally overwriting existing files are: 1 2 alias mv = \"mv -i\" alias cp = \"cp -i\"","title":"rm: ReMove files"},{"location":"unix.html#cat-catenate-file-content-to-the-screen","text":"1 ooiwt@pe111:~/tut01$ cat hello.c less is variant of cat that includes features to read each page leisurely) 1 ooiwt@pe111:~/tut01$ less hello.c In less , use <space> to move down one page, b to move Back up one page, and q to Quit.","title":"cat: CATenate file content to the screen"},{"location":"unix.html#man-online-manual","text":"An online help facility is available in UNIX via the man command ( man stands for MANual). To look for more information about any UNIX command, for example, ls , type man ls . Type man man and refer to Man Pages to find out more about the facility. To exit man , press q . Now that you are familiar with how the UNIX bash works, I won't show the command prompt any more in the rest of this article.","title":"man: Online MANual"},{"location":"unix.html#chmod-changing-unix-file-permission","text":"It is important to guide our files properly on a multi-user system where users share the same file system. UNIX has a simple mechanism to for ensuring that: every file and directory has nine bits of access permission, corresponds to three access operations, read ( r ), write ( w ), and execute ( x ), for four classes of users, the user who owns of the file ( u ), users in the same group as the owner ( g ), all other users ( o ), and all users ( a ) (union of all three classes before) When you run ls -l , you will see the permission encoded as strings that look like -rw------- or drwx--x--x besides other file information. The first character indicates if the file is a directory ( d ) or not ( - ). The next three characters are the permission for the owner. rwx means that the owner can do all three: reading, writing, and executing, rw- means that the owner can read and write, but cannot execute. The next three characters are the permission for the users in the same group. The last three characters are the permission for the users in the other groups. To change permission, we use the chmod command. Let's say that we want to remove the read and write permission from all other users in the group. You can run: 1 chmod g-rw <file> where <file> is the name of the file whose permission you want to change. This would change the permission from -rw-rw-rw- to -rw----rw- , or from -rwxr--r-- to -rwx---r-- . To add executable permission to everyone, you can run: 1 chmod a+x <file> This would change the permission from -rw-rw-rw- to -rwxrwxrwx , or from -rwxr--r-- to rwxr-xr-x , and so on. You get the idea. Another way to change the permission is to set the permission directly, instead of adding with + and removing with - . To do this, one convenient way is to treat the permission for each class of user as a 3-bit binary number between 0 to 7. So, rwx is 7, rw- is 6, -w- is 2, --- is 0, etc. To set the permission of a file to -r--r--r-- (readable by everyone), run: 1 chmod 444 <file> To set the permission to -rw------- , run: 1 chmod 600 <file> and so on. It is important to ensure that your code is not readable and writable by other students, especially for graded lab exercises.","title":"chmod: Changing UNIX File Permission"},{"location":"unix.html#scp-secure-copy","text":"Secure copy, or scp , is one way to transfer files from the programming environments to your local computer for archiving or storage. Let's say you want to transfer a set of C files from the directory a01 to your local computer, then, on your local computer, run: 1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/*.c . Warning If you have files with the same name in the remote directory, the files will be overwritten without warning. I have lost my code a few times due to scp . The expression *.c is a regular expression that means all files with filename ending with .c . You can copy specific files as well. For instance, 1 ooiwt@macbook:~$ scp ooiwt@pe111:~/a01/hello.c . scp supports -r (recursive copy) as well.","title":"scp: Secure Copy"},{"location":"unix.html#specifying-a-path-in-unix","text":"In any command above, when we need to refer to a directory or a file, we need to specify an unambiguous location of the directory or the file. The most precise way to specify the location is to use the full path, or the absolute path . For instance: 1 cp /home/o/ooiwt/tut01/hello.c /home/o/ooiwt/tut01/hello_world.c That's a lot of characters to type. We could shorten it in a few ways. We could specify the location with respect to the home directory using ~ . ~ooiwt refers to the home directory of user ooiwt . 1 cp ~ooiwt/tut01/hello.c ~ooiwt/tut01/hello_world.c If you are ooiwt , then you can omit ooiwt , since ~ without any username refers to your home directory. 1 cp ~/tut01/hello.c ~/tut01/hello_world.c Or we could specify the location with respect to the current directory. Suppose the current working directory is ~/tut01 (i.e., we have cd into ~/tut01 ), then we could say this: 1 cp ./hello.c ./hello_world.c Recall that a single dot . refers to the current directory. The ./ however is redundant unless you are executing a command. Since, by specifying a file name or a directory without a path (i.e., not using any / ), the bash looks for the file or directory in the current directory. So, we could just do: 1 cp hello.c hello_world.c Another important short form for relative location is .. . Recall that this refers to the parent directory. Suppose that the current directory is in ~/tut02 . Then, to copy the files in ~/tut01 , you can run: 1 cp ../tut01/hello.c ../tut01/hello_world.c I run fish on my macOS, as you might have noticed during the in-class demos. You can use any shell you like if you know what you are doing. Otherwise, bash is a popular one. \u21a9","title":"Specifying A Path in UNIX"},{"location":"vim.html","text":"Vim Tips I collected some tips on vim that I find helpful. If you are new to vim , please try out the command vimtutor on any machine where vim is installed, and check out the nice article Learn vim Progressively . 1. Useful Configuration You can configure your vim by putting your configuration options and scripts in the ~/.vimrc file (a hidden file named .vimrc in your home directory). This file will be loaded whenever you start vim . You can copy a sample .vimrc file from ~cs1010/.vimrc to your home directory. You can edit this file ~/.vimrc just like any other file, using vim . Help In vim, the command :help <topic> shows help about a particular topic in vim . Example, :help backup . Backup Files You can ask vim to automatically backup files that you edit. This has been a lifesaver for me on multiple occasions. In your ~/.vimrc file, 1 set backup will cause a copy of your file to be saved with suffix ~ appended to its name every time you save. I prefer not to clutter my working directory, so I set 1 set backupdir=~/.backup and create a directory named ~/.backup to store my backup files. So if you made changes to a file that you regretted, or if you accidentally deleted a file, you can check under ~/.backup to see if the backup can save you. Syntax Highlighting If for some reasons, syntax highlighting is not on by default, add this to your ~/.vimrc : 1 syntax on Ruler and Numbers If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc 1 set ruler will display the line number and the column number on the lower right corner. You can also add 1 set number to label each line with a line number. Auto Indentation Proper indentation is important to make your code readable (to yourself and others). You should enable this in vim with: 1 2 set autoindent set smartindent Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing { and } ) and indent your code accordingly. The size of the indentation is based on the setting shiftwidth . For CS1010, please set it to either 2 or 4 : 1 set shiftwidth=2 2. Navigation Basic Navigation Use K and J keys to move up and down (just like Gmail and Facebook!). H and L to move left and right. Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many H J K L to see how you can navigate faster). W jump to the beginning of the next word B ump to the beginning of the previous word (reverse of w ) E jump to the end of the word (or next word when pressed again) F char: search forward in the line and sit on the next matching char T char: search forward in the line and sit on one space before the matching char Shift + 4 ($) jump to the end of line 0 jump to the beginning of the line Shift + 6 (^) jump to the first non-blank character of the line Shift + 5 (%) jump between matching parentheses Ctrl + D jump forward (Down) half page Ctrl + F jump Forward one page Ctrl + U jump backward (Up) half page Ctrl + B jump Backward half page Jumping to a Line If the compiler tells you there is an error on Line \\(x\\) , you can issue :<x> to jump to Line \\(x\\) . For instance, :40 will go to Line 40. 3. Editing Operations Undo Since we are on the topic of correcting mistakes, U in command mode undo your changes. Prefix it with a number \\(n\\) to undo \\(n\\) times. If you want to undo your undo, Ctrl + R will redo. Navigation + Editing vim is powerful because you can combine operations with navigation . For instance C to change, D to delete, Y to yank (copy). Since W is the navigation command to move over the current word, combining them we get: C W change the current word (delete the current word and enter insert mode) D W delete the current word Y W yank the current word (copy word into buffer) Can you guess what each of these do: D F Shift + 0 D F Shift + 0 C Shift + 4 Y 0 If you repeat the operation C , D , and Y , it applies to the whole line, so: C C change the whole line D D delete the whole line Y Y yank the whole line You can add a number before an operation to specify how many times you want to repeat an operation. So 5 D D deletes 5 lines, 5 D W deletes 5 words, etc. See the article Operator, the True Power of Vim for more details. Swapping Lines Sometimes you want to swap the order of two lines of code, in command mode, D D P will do the trick. D D deletes the current line, P paste it after the current line, in effect swapping the order of the two lines. Commenting blocks of code Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in vim : Place the cursor on the first line of the block of code you want to comment on. 0 to jump to the beginning of the line Shift + V enter visual mode Use the arrow key to select the block of code you want to comment on. Shift + I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected) / / to insert the C comment character (you will see it inserted in the current line, but don't worry) Esc to escape from the visual code. To uncomment, Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line Ctrl + V enter block visual mode Use the arrow key to select the columns of text containing // X to delete them 4. Other Advanced Features Search and Replace in vim 1 :%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurrence of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement Shell Command If you need to issue a shell command quickly, you don't have to exit vim , run the command, and launch vim again. You can use ! , 1 :!<command> will issue the command to shell. E.g., 1 :!ls You can use this to compile your current file, without exiting vim . 1 :!make make is actually a builtin command for vim so you can also simply run 1 :make Abbreviation You can use the command ab to abbreviate frequently typed commands. E.g., in your ~/.vimrc , 1 ab pl cs1010_print_long( Now, when you type pl , it will be expanded into cs1010_print_long( Auto-Completion You can use Ctrl + P or Ctrl + N to auto-complete. By default, the autocomplete dictionary is based on the text in your current editing buffers. This is a very useful keystroke saver for long function and variable names. Auto-Indent the Whole File You can G G = Shift + G in command mode to auto-indent the whole file. G G is the command to go to the beginning of the file. = is the command to indent. Shift + G is the command to go to the end of the file. Splitting vim 's Viewport :sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl + W Ctrl + W moves between the different vim viewports 5. Plugins Syntax and Style Checker I use syntastic to check for style and syntax whenever I save a file. syntastic is a vim plugin. My .vimrc configuration file contains the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \"For syntastic set laststatus=2 set statusline+=%#warningmsg# set statusline+=%{SyntasticStatuslineFlag()} set statusline+=%* let g:syntastic_error_symbol = '\u2717' let g:syntastic_warning_symbol = '\u26a0' let g:syntastic_always_populate_loc_list = 1 let g:syntastic_auto_loc_list = 1 let g:syntastic_check_on_open = 1 let g:syntastic_check_on_wq = 0 let g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ] let g:syntastic_c_compiler = 'clang' let g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude' let g:syntastic_c_clang_tidy_args = '-checks=*' let g:syntastic_c_compiler_options = '-Wall -Iinclude' let g:syntastic_c_include_dirs = [ '../include', 'include' ] let g:syntastic_c_clang_tidy_post_args = \"\" By default, clang-tidy does not know where to find the header files. So if you include non-standard C headers, it will complain that it cannot find headers. To resolve this, we need to tell clang-tidy the compilation flags that we use when compiling our program. We can do this by creating a file named compile_flags.txt in your working directory (where your C files are located), containing one compilation flag per line. For instance, if the header files are located in /home/course/cs1010/include , your compile_flags.txt should contain the following two lines: 1 2 -Wall -I/home/course/cs1010/include","title":"Vim"},{"location":"vim.html#vim-tips","text":"I collected some tips on vim that I find helpful. If you are new to vim , please try out the command vimtutor on any machine where vim is installed, and check out the nice article Learn vim Progressively .","title":"Vim Tips"},{"location":"vim.html#1-useful-configuration","text":"You can configure your vim by putting your configuration options and scripts in the ~/.vimrc file (a hidden file named .vimrc in your home directory). This file will be loaded whenever you start vim . You can copy a sample .vimrc file from ~cs1010/.vimrc to your home directory. You can edit this file ~/.vimrc just like any other file, using vim .","title":"1. Useful Configuration"},{"location":"vim.html#help","text":"In vim, the command :help <topic> shows help about a particular topic in vim . Example, :help backup .","title":"Help"},{"location":"vim.html#backup-files","text":"You can ask vim to automatically backup files that you edit. This has been a lifesaver for me on multiple occasions. In your ~/.vimrc file, 1 set backup will cause a copy of your file to be saved with suffix ~ appended to its name every time you save. I prefer not to clutter my working directory, so I set 1 set backupdir=~/.backup and create a directory named ~/.backup to store my backup files. So if you made changes to a file that you regretted, or if you accidentally deleted a file, you can check under ~/.backup to see if the backup can save you.","title":"Backup Files"},{"location":"vim.html#syntax-highlighting","text":"If for some reasons, syntax highlighting is not on by default, add this to your ~/.vimrc : 1 syntax on","title":"Syntax Highlighting"},{"location":"vim.html#ruler-and-numbers","text":"If you prefer to show the line number you are on and the column number you are on, adding the commands to ~/.vimrc 1 set ruler will display the line number and the column number on the lower right corner. You can also add 1 set number to label each line with a line number.","title":"Ruler and Numbers"},{"location":"vim.html#auto-indentation","text":"Proper indentation is important to make your code readable (to yourself and others). You should enable this in vim with: 1 2 set autoindent set smartindent Autoindent will cause the next line to have the same indentation as the previous line; while smartindent has some understanding of C-like syntax (such as recognizing { and } ) and indent your code accordingly. The size of the indentation is based on the setting shiftwidth . For CS1010, please set it to either 2 or 4 : 1 set shiftwidth=2","title":"Auto Indentation"},{"location":"vim.html#2-navigation","text":"","title":"2. Navigation"},{"location":"vim.html#basic-navigation","text":"Use K and J keys to move up and down (just like Gmail and Facebook!). H and L to move left and right. Other shortcuts (no need to memorize them now, just refer back when you feel like you are typing too many H J K L to see how you can navigate faster). W jump to the beginning of the next word B ump to the beginning of the previous word (reverse of w ) E jump to the end of the word (or next word when pressed again) F char: search forward in the line and sit on the next matching char T char: search forward in the line and sit on one space before the matching char Shift + 4 ($) jump to the end of line 0 jump to the beginning of the line Shift + 6 (^) jump to the first non-blank character of the line Shift + 5 (%) jump between matching parentheses Ctrl + D jump forward (Down) half page Ctrl + F jump Forward one page Ctrl + U jump backward (Up) half page Ctrl + B jump Backward half page","title":"Basic Navigation"},{"location":"vim.html#jumping-to-a-line","text":"If the compiler tells you there is an error on Line \\(x\\) , you can issue :<x> to jump to Line \\(x\\) . For instance, :40 will go to Line 40.","title":"Jumping to a Line"},{"location":"vim.html#3-editing-operations","text":"","title":"3. Editing Operations"},{"location":"vim.html#undo","text":"Since we are on the topic of correcting mistakes, U in command mode undo your changes. Prefix it with a number \\(n\\) to undo \\(n\\) times. If you want to undo your undo, Ctrl + R will redo.","title":"Undo"},{"location":"vim.html#navigation-editing","text":"vim is powerful because you can combine operations with navigation . For instance C to change, D to delete, Y to yank (copy). Since W is the navigation command to move over the current word, combining them we get: C W change the current word (delete the current word and enter insert mode) D W delete the current word Y W yank the current word (copy word into buffer) Can you guess what each of these do: D F Shift + 0 D F Shift + 0 C Shift + 4 Y 0 If you repeat the operation C , D , and Y , it applies to the whole line, so: C C change the whole line D D delete the whole line Y Y yank the whole line You can add a number before an operation to specify how many times you want to repeat an operation. So 5 D D deletes 5 lines, 5 D W deletes 5 words, etc. See the article Operator, the True Power of Vim for more details.","title":"Navigation + Editing"},{"location":"vim.html#swapping-lines","text":"Sometimes you want to swap the order of two lines of code, in command mode, D D P will do the trick. D D deletes the current line, P paste it after the current line, in effect swapping the order of the two lines.","title":"Swapping Lines"},{"location":"vim.html#commenting-blocks-of-code","text":"Sometimes we need to comment out a whole block of code in C for testing purposes. There are several ways to do it in vim : Place the cursor on the first line of the block of code you want to comment on. 0 to jump to the beginning of the line Shift + V enter visual mode Use the arrow key to select the block of code you want to comment on. Shift + I to insert at the beginning of the line (here, since we already selected the block, we will insert at the beginning of every selected) / / to insert the C comment character (you will see it inserted in the current line, but don't worry) Esc to escape from the visual code. To uncomment, Place the cursor on the first line of the block of code you want to comment. 0 to jump to the beginning of the line Ctrl + V enter block visual mode Use the arrow key to select the columns of text containing // X to delete them","title":"Commenting blocks of code"},{"location":"vim.html#4-other-advanced-features","text":"","title":"4. Other Advanced Features"},{"location":"vim.html#search-and-replace-in-vim","text":"1 :%s/oldWord/newWord/gc : enters the command mode. % means apply to the whole document, s means substitute, g means global (otherwise, only the first occurrence of each line is replaced). c is optional -- adding it cause vim to confirm with you before each replacement","title":"Search and Replace in vim"},{"location":"vim.html#shell-command","text":"If you need to issue a shell command quickly, you don't have to exit vim , run the command, and launch vim again. You can use ! , 1 :!<command> will issue the command to shell. E.g., 1 :!ls You can use this to compile your current file, without exiting vim . 1 :!make make is actually a builtin command for vim so you can also simply run 1 :make","title":"Shell Command"},{"location":"vim.html#abbreviation","text":"You can use the command ab to abbreviate frequently typed commands. E.g., in your ~/.vimrc , 1 ab pl cs1010_print_long( Now, when you type pl , it will be expanded into cs1010_print_long(","title":"Abbreviation"},{"location":"vim.html#auto-completion","text":"You can use Ctrl + P or Ctrl + N to auto-complete. By default, the autocomplete dictionary is based on the text in your current editing buffers. This is a very useful keystroke saver for long function and variable names.","title":"Auto-Completion"},{"location":"vim.html#auto-indent-the-whole-file","text":"You can G G = Shift + G in command mode to auto-indent the whole file. G G is the command to go to the beginning of the file. = is the command to indent. Shift + G is the command to go to the end of the file.","title":"Auto-Indent the Whole File"},{"location":"vim.html#splitting-vims-viewport","text":":sp file.c splits the vim window horizontally :vsp file.c splits the vim window vertically Ctrl + W Ctrl + W moves between the different vim viewports","title":"Splitting vim's Viewport"},{"location":"vim.html#5-plugins","text":"","title":"5. Plugins"},{"location":"vim.html#syntax-and-style-checker","text":"I use syntastic to check for style and syntax whenever I save a file. syntastic is a vim plugin. My .vimrc configuration file contains the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \"For syntastic set laststatus=2 set statusline+=%#warningmsg# set statusline+=%{SyntasticStatuslineFlag()} set statusline+=%* let g:syntastic_error_symbol = '\u2717' let g:syntastic_warning_symbol = '\u26a0' let g:syntastic_always_populate_loc_list = 1 let g:syntastic_auto_loc_list = 1 let g:syntastic_check_on_open = 1 let g:syntastic_check_on_wq = 0 let g:syntastic_c_checkers = [ 'clang_tidy', 'clang' ] let g:syntastic_c_compiler = 'clang' let g:syntastic_c_clang_args = '-Wall -Werror -Wextra -Iinclude' let g:syntastic_c_clang_tidy_args = '-checks=*' let g:syntastic_c_compiler_options = '-Wall -Iinclude' let g:syntastic_c_include_dirs = [ '../include', 'include' ] let g:syntastic_c_clang_tidy_post_args = \"\" By default, clang-tidy does not know where to find the header files. So if you include non-standard C headers, it will complain that it cannot find headers. To resolve this, we need to tell clang-tidy the compilation flags that we use when compiling our program. We can do this by creating a file named compile_flags.txt in your working directory (where your C files are located), containing one compilation flag per line. For instance, if the header files are located in /home/course/cs1010/include , your compile_flags.txt should contain the following two lines: 1 2 -Wall -I/home/course/cs1010/include","title":"Syntax and Style Checker"},{"location":"zoom.html","text":"Using Zoom Logging into Zoom You can only join the sessions if you log in into Zoom nus-sg.zoom.us using your NUS account. To do so, you have to first log out of Zoom if you have already logged in using your non-NUS Zoom account. There are two options: Option 1 go to https://nus-sg.zoom.us/ directly and click \"Sign In\"; Follow the given instructions by entering your NUSNET ID and password. Option 2 If you get to Zoom through another link, you might be presented with the following screen. Do not enter your NUS email address and password on this screen. Instead, click on \"Sign in with SSO\". You will be presented with this screen: Enter nus-sg into the field \"Company Domain\" and click continue. You will be prompted to enter your NUSNET ID and password. Follow the instruction on the screen. Using Zoom Desktop Client Some students have reported issues when trying to join a breakout room when using Web version of Zoom (i.e., connecting through a Web browser). Please join the workshop by using the Zoom application instead of through a Web browser. Links to Join Zoom The Zoom session information is shared privately on Piazza .","title":"Zoom"},{"location":"zoom.html#using-zoom","text":"","title":"Using Zoom"},{"location":"zoom.html#logging-into-zoom","text":"You can only join the sessions if you log in into Zoom nus-sg.zoom.us using your NUS account. To do so, you have to first log out of Zoom if you have already logged in using your non-NUS Zoom account. There are two options:","title":"Logging into Zoom"},{"location":"zoom.html#option-1","text":"go to https://nus-sg.zoom.us/ directly and click \"Sign In\"; Follow the given instructions by entering your NUSNET ID and password.","title":"Option 1"},{"location":"zoom.html#option-2","text":"If you get to Zoom through another link, you might be presented with the following screen. Do not enter your NUS email address and password on this screen. Instead, click on \"Sign in with SSO\". You will be presented with this screen: Enter nus-sg into the field \"Company Domain\" and click continue. You will be prompted to enter your NUSNET ID and password. Follow the instruction on the screen.","title":"Option 2"},{"location":"zoom.html#using-zoom-desktop-client","text":"Some students have reported issues when trying to join a breakout room when using Web version of Zoom (i.e., connecting through a Web browser). Please join the workshop by using the Zoom application instead of through a Web browser.","title":"Using Zoom Desktop Client"},{"location":"zoom.html#links-to-join-zoom","text":"The Zoom session information is shared privately on Piazza .","title":"Links to Join Zoom"}]}